(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{447:function(s,a,t){"use strict";t.r(a);var v=t(19),n=Object(v.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"jvm探究"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm探究"}},[s._v("#")]),s._v(" JVM探究")]),s._v(" "),t("ul",[t("li",[s._v("谈谈你对JVM的理解？java8虚拟机和之前的变化更新？")]),s._v(" "),t("li",[s._v("什么是OOM，什么是栈溢出StackOverFlowError？怎么分析？")]),s._v(" "),t("li",[s._v("JVM的常用调优参数有哪些？")]),s._v(" "),t("li",[s._v("内存快照如何抓取，怎么分析Dump文件？")]),s._v(" "),t("li",[s._v("谈谈JVM中，类加载器你的认识？")])]),s._v(" "),t("h2",{attrs:{id:"jvm的位置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm的位置"}},[s._v("#")]),s._v(" JVM的位置")]),s._v(" "),t("div",{staticClass:"language-mermaid line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("graph TD\nA[JRE--JVM]--\x3eB[操作系统 Windows Linux Mac]\nB--\x3eA\nB--\x3eC[硬件体系 Intel Spac]\nC--\x3eB\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("h2",{attrs:{id:"jvm的体系结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm的体系结构"}},[s._v("#")]),s._v(" JVM的体系结构")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("简易图")]),s._v(" "),t("p",[t("img",{attrs:{src:"/JVM.assets/JVM.jpg",alt:"JVM"}})])]),s._v(" "),t("li",[t("p",[s._v("细节图")]),s._v(" "),t("p",[t("img",{attrs:{src:"/JVM.assets/JVM%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg",alt:"JVM架构图"}})])])]),s._v(" "),t("h2",{attrs:{id:"类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[s._v("#")]),s._v(" 类加载器")]),s._v(" "),t("ul",[t("li",[s._v("作用：加载Class文件")])]),s._v(" "),t("p",[t("img",{attrs:{src:"/JVM.assets/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.jpg",alt:"类加载器"}})]),s._v(" "),t("ol",[t("li",[s._v("虚拟机自带的加载器")]),s._v(" "),t("li",[s._v("启动类(根)加载器")]),s._v(" "),t("li",[s._v("扩展类加载器")]),s._v(" "),t("li",[s._v("应用程序(系统类)加载器")])]),s._v(" "),t("ul",[t("li",[s._v("java本地方法：\n"),t("ul",[t("li",[s._v("Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C")]),s._v(" "),t("li",[s._v("JVM怎样使Native Method跑起来：\n"),t("ul",[t("li",[s._v("我们知道，当一个类第一次被使用到时，这个类的字节码会被加载到内存，并且只会载入一次。在这个被加载的字节码的入口维持着一个该类所有方法描述符的list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public之类）等等")]),s._v(" "),t("li",[s._v("如果一个方法描述符内有native，这个描述符块将有一个指向该方法的实现的指针。这些实现在一些DLL文件内，但是它们会被操作系统加载到java程序的地址空间。当一个带有本地方法的类被加载时，其相关的DLL并未被加载，因此指向方法实现的指针并不会被设置。当本地方法被调用之前，这些DLL才会被加载，这是通过调用java.system.loadLibrary()实现的")])])])])])]),s._v(" "),t("h2",{attrs:{id:"双亲委派机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派机制"}},[s._v("#")]),s._v(" 双亲委派机制")]),s._v(" "),t("ul",[t("li",[s._v("为了保证安全，类加载器会从最顶层（根加载器）寻找要加载的类的类名")]),s._v(" "),t("li",[s._v("APP--\x3eEXC--\x3eBOOT（如果有相同包名类名，会执行更上级的加载器）")])]),s._v(" "),t("ol",[t("li",[s._v("类加载器收到类加载的请求")]),s._v(" "),t("li",[s._v("将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类(根)加载器BOOT")]),s._v(" "),t("li",[s._v("启动加载器检查是否能够加载这个类，能加载就结束，使用当前的加载器，否则，抛出异常，通知子加载器进行加载\n"),t("ul",[t("li",[s._v("懒鬼加载器：app不想干 ，给ext，ext也不想干，给boot, boot干活找不到，给ext，ext找不到，给app")])])]),s._v(" "),t("li",[s._v("重复步骤3")]),s._v(" "),t("li",[s._v("都没找到报经典错误ClassNotFound")])]),s._v(" "),t("ul",[t("li",[s._v("java调用不到根加载器，原因是根加载器是用C++写的")])]),s._v(" "),t("h2",{attrs:{id:"沙箱安全机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#沙箱安全机制"}},[s._v("#")]),s._v(" 沙箱安全机制")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("Java安全模型的核心就是Java沙箱(sandbox)，什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将Java代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱"),t("strong",[s._v("主要限制系统资源访问")]),s._v("，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样")]),s._v(" "),t("ul",[t("li",[s._v("所有的ava程序运行都可以指定沙箱，可以定制安全策略")])])]),s._v(" "),t("li",[t("p",[s._v("在ava中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱(Sandbox)机制。如下图所示JDK1.0安全模型")]),s._v(" "),t("p",[t("img",{attrs:{src:"/JVM.assets/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B61.png",alt:"沙箱安全机制1"}})])]),s._v(" "),t("li",[t("p",[s._v("但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1安全模型")]),s._v(" "),t("p",[t("img",{attrs:{src:"/JVM.assets/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B62.png",alt:"沙箱安全机制2"}})])]),s._v(" "),t("li",[t("p",[s._v("在Java1.2版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型")]),s._v(" "),t("p",[t("img",{attrs:{src:"/JVM.assets/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B63.png",alt:"沙箱安全机制3"}})])]),s._v(" "),t("li",[t("p",[s._v("当前最新的安全机制实现，则引入了域(Domain)的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain)，对应不一样的权限(Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示最新的安全模型(jdk 1.6)")]),s._v(" "),t("p",[t("img",{attrs:{src:"/JVM.assets/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B64.png",alt:"沙箱安全机制4"}})])]),s._v(" "),t("li",[t("p",[s._v("组成沙箱的基本组件：")]),s._v(" "),t("ul",[t("li",[s._v("字节码校验器(bytecode verifier)：确保lava类文件遵循lava语言规范。这样可以帮助lava程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类")]),s._v(" "),t("li",[s._v("类装载器(class loader) ：其中类装载器在3个方面对Java沙箱起作用\n"),t("ul",[t("li",[s._v("它防止恶意代码去干涉善意的代码 //双亲委派机制")]),s._v(" "),t("li",[s._v("它守护了被信任的类库边界")]),s._v(" "),t("li",[s._v("它将代码归入保护域，确定了代码可以进行哪些操作")])])]),s._v(" "),t("li",[s._v("虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见")])])]),s._v(" "),t("li",[t("p",[s._v("类装载器采用的机制是双亲委派模式")]),s._v(" "),t("ol",[t("li",[s._v("从最内层VM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用")]),s._v(" "),t("li",[s._v("由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效")])]),s._v(" "),t("ul",[t("li",[s._v("存取控制器(access controller)：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定")]),s._v(" "),t("li",[s._v("安全管理器(security manager)：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高")]),s._v(" "),t("li",[s._v("安全软件包(security package)：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括:\n"),t("ul",[t("li",[s._v("安全提供者")]),s._v(" "),t("li",[s._v("消息摘要")]),s._v(" "),t("li",[s._v("数字签名 keytools")]),s._v(" "),t("li",[s._v("加密")]),s._v(" "),t("li",[s._v("鉴别")])])])])])]),s._v(" "),t("h2",{attrs:{id:"native"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#native"}},[s._v("#")]),s._v(" Native")]),s._v(" "),t("ul",[t("li",[s._v("native：凡是带了native关键字的，说明java的作用范围达不到了，会去调用底层C语言的库，会被放入本地方法栈")]),s._v(" "),t("li",[s._v("之后会"),t("strong",[s._v("调用本地方法接口--JNI")]),s._v("(java native interface)")]),s._v(" "),t("li",[s._v("JNI作用："),t("strong",[s._v("扩展java的使用")]),s._v("，融合不同的编程语言为java所用")]),s._v(" "),t("li",[s._v("Java诞生的时候C、C++横行，"),t("strong",[s._v("想要立足，必须要有调用C、C++的程序")])]),s._v(" "),t("li",[s._v("它在内存区域中专门开辟了一块标记区域："),t("strong",[s._v("native method stack")]),s._v("，专门"),t("strong",[s._v("登记")]),s._v("native方法")]),s._v(" "),t("li",[s._v("在"),t("strong",[s._v("最终执行")]),s._v("的时候，通过"),t("strong",[s._v("JNI加载")]),s._v("本地方法库中的方法")]),s._v(" "),t("li",[s._v("Java程序驱动打印机，管理系统才会用到，其他应用较少")]),s._v(" "),t("li",[s._v("现在我们调用其他语言的方法也可以调用其他接口：socket，webservice，http（通过传输参数间接实现语言调用）")])]),s._v(" "),t("h2",{attrs:{id:"pc寄存器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pc寄存器"}},[s._v("#")]),s._v(" PC寄存器")]),s._v(" "),t("ul",[t("li",[s._v("程序计数器：Program Counter Register\n"),t("ul",[t("li",[s._v("每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向像一条指令的地址，也即将要执行的指令代码)，在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计")])])])]),s._v(" "),t("h2",{attrs:{id:"jvm各区图解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm各区图解"}},[s._v("#")]),s._v(" JVM各区图解")]),s._v(" "),t("p",[t("img",{attrs:{src:"/JVM.assets/jdk8.png",alt:"jdk8"}})]),s._v(" "),t("p",[t("img",{attrs:{src:"/JVM.assets/jvm%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png",alt:"jvm存储结构"}})]),s._v(" "),t("h2",{attrs:{id:"方法区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[s._v("#")]),s._v(" 方法区")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("JDK8后方法区在元空间里")])]),s._v(" "),t("li",[t("p",[s._v("Method Area方法区")]),s._v(" "),t("ul",[t("li",[s._v("方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，"),t("strong",[s._v("此区域属于共享区间")])]),s._v(" "),t("li",[s._v("=="),t("strong",[s._v("(static)"),t("strong",[s._v("静态变量、")]),s._v("(final)"),t("strong",[s._v("常量、")]),s._v("(Class)"),t("strong",[s._v("类信息(构造方法、接口定义)、运行时的")]),s._v("常量池")]),s._v("存在方法区中（字符常量池1.7前在方法区，后在堆内存中），方法编译出的字节码也是保存在这个区域，"),t("strong",[s._v("但是实例变量")]),s._v("存在堆内存中，和方法区无关==")]),s._v(" "),t("li",[s._v("运行时常量池：class文件元信息描述，"),t("strong",[s._v("编译后的代码数据")]),s._v("，引用类型数据，类文件常量池")]),s._v(" "),t("li",[s._v('字符串常量池（堆中）：Java中的字符串常量池（String Pool）是存储在Java堆内存中的字符串池。我们知道String是java中比较特殊的类，我们可以使用new运算符创建String对象，也可以用双引号（""）创建字串对象')]),s._v(" "),t("li",[s._v("类信息在方法区，类对象储存在堆")])])])]),s._v(" "),t("h2",{attrs:{id:"栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[s._v("#")]),s._v(" 栈")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("是一种数据结构，像队列一样。栈：先进后出(FILO first-in-last-out)，后进先出。队列：先进先出(FIFO)，后进后出")])]),s._v(" "),t("li",[t("p",[s._v("一个JVM可以有很多栈")])]),s._v(" "),t("li",[t("p",[s._v("程序 = 数据结构 + 算法")])]),s._v(" "),t("li",[t("p",[s._v("程序 = 框架 + 业务逻辑 ：易被淘汰")])]),s._v(" "),t("li",[t("p",[s._v("栈：栈内存，主管程序的运行、生命周期和线程同步。线程结束，栈内存释放，对于栈来说，==不存在垃圾回收问题==")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("方法是存在方法区")]),s._v("的，并且方法区中是方法的静态表现\n"),t("ul",[t("li",[s._v("栈区中的每个开辟的栈帧是方法的一次执行过程，方法开始执行时产生，执行完销毁，他是方法的动态表现，并且方法被调用几次，就会出现几次")])])]),s._v(" "),t("li",[s._v("=="),t("strong",[s._v("方法内定义的基本数据类型放在栈桢")]),s._v("==中，栈里面的数据是线程私有的，不共享\n"),t("ul",[t("li",[s._v("在方法中声明的变量，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因")])])]),s._v(" "),t("li",[s._v("在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量，对象的引用在栈中\n"),t("ol",[t("li",[s._v("当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在JAVA虚拟机栈中")]),s._v(" "),t("li",[s._v("当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在JAVA虚拟机的栈中，该变量所指向的对象是放在堆类存中的。")])])])])]),s._v(" "),t("li",[t("p",[s._v("在内存中对象实例化的过程：")]),s._v(" "),t("ol",[t("li",[t("p",[s._v("在程序的执行过程中，首先"),t("strong",[s._v("类中的成员变量和方法体会进入到方法区")])])]),s._v(" "),t("li",[t("p",[s._v("程序执行到 main() 方法时，"),t("strong",[s._v("main()函数方法体会进入栈区")]),s._v("，这一过程叫做进栈(压栈)，定义了一个用于"),t("strong",[s._v("指向类Person实例的变量 person")])])]),s._v(" "),t("li",[t("p",[s._v("程序执行到 Person person = new Person(); 就会在"),t("strong",[s._v("堆内存开辟一块内存区间，用于存放 Person 实例对象和其属性值")])])]),s._v(" "),t("li",[t("p",[s._v("接下来对 person 对象进行赋值， person.name = “小二” ; perison.age = 13; 根据栈中实例对象属性引用地址找到真实地址进行赋值操作")])]),s._v(" "),t("li",[t("p",[s._v("当程序走到 sing() 方法时，先到栈区找到 person这个引用变量，然后根据该地址值在堆内存中找到 Person 实例对象 进行方法调用。在方法体被调用完成后，就会立刻马上从栈内弹出（出栈）。最后，在main()函数完成后，main()函数也会出栈")])])])])]),s._v(" "),t("h2",{attrs:{id:"三种jvm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三种jvm"}},[s._v("#")]),s._v(" 三种JVM")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("Sun公司 "),t("code",[s._v("HotSpot")])])]),s._v(" "),t("li",[t("p",[s._v("BEA "),t("code",[s._v("JRockit")])])]),s._v(" "),t("li",[t("p",[s._v("IBM "),t("code",[s._v("J9 VM")])])]),s._v(" "),t("li",[t("p",[s._v("我们学习的都是："),t("code",[s._v("HotSpot")])])])]),s._v(" "),t("h2",{attrs:{id:"堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[s._v("#")]),s._v(" 堆")]),s._v(" "),t("ul",[t("li",[s._v("Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的")]),s._v(" "),t("li",[s._v("类加载器读取了类文件后，"),t("strong",[s._v("一般会把什么东西放到堆中：引用类型的真实对象")])]),s._v(" "),t("li",[s._v("堆内存中还要细分为三个区域：\n"),t("ul",[t("li",[s._v("新生区（伊甸园）")]),s._v(" "),t("li",[s._v("老年区")]),s._v(" "),t("li",[s._v("永久区")]),s._v(" "),t("li",[s._v("JDK8以后在堆中移除了永久代（区），把这个方法区移到了本地内存（Native memory）(不在虚拟机内存里)中，即元空间")])])]),s._v(" "),t("li",[s._v("GC垃圾回收主要是在伊甸园区和老年区，假设内存满了，OOM，堆内存不够。OutOfMemoryError")])]),s._v(" "),t("h3",{attrs:{id:"新生区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新生区"}},[s._v("#")]),s._v(" 新生区")]),s._v(" "),t("ul",[t("li",[s._v("类对象：诞生和成长甚至死亡")]),s._v(" "),t("li",[s._v("伊甸园：绝大部分的对象都是在这个区new出来的\n"),t("ul",[t("li",[t("strong",[s._v("JVM对象的内存分配对象优先在伊甸园分配，但大对象会直接进入老年代")])])])]),s._v(" "),t("li",[s._v("JVM 每次只会使用 Eden 和其中的一块 Survivor(幸存者) 区域来为对象服务，所以无论什么时候，"),t("strong",[s._v("总是有一块 Survivor 区域是空闲着的")]),s._v("。因此，新生代"),t("strong",[s._v("实际可用的内存空间为 9/10 ( 即90% )的新生代空间")])]),s._v(" "),t("li",[s._v("幸存者区（0,1）（from, to）是一个"),t("strong",[s._v("动态变化")]),s._v("的区域，"),t("strong",[s._v("两个区域可能变换位置，谁空谁是to区")]),s._v(" "),t("ul",[t("li",[s._v("每次GC都会将Eden活的对象移到幸存者区中，也就是说"),t("strong",[s._v("一旦Eden区被GC后，就会是空的")])])])]),s._v(" "),t("li",[s._v("当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？再移动到养老区")])]),s._v(" "),t("h3",{attrs:{id:"老年区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#老年区"}},[s._v("#")]),s._v(" 老年区")]),s._v(" "),t("ul",[t("li",[s._v("当对象在新生区经历过多次（默认15次）GC依然幸存则进入老年区")]),s._v(" "),t("li",[s._v("当老年区也满了，那么这个时候将产生MajorGC（FullGC），进行养老区的内存清理。若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”")])]),s._v(" "),t("h3",{attrs:{id:"永久区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#永久区"}},[s._v("#")]),s._v(" 永久区")]),s._v(" "),t("ul",[t("li",[s._v("JDK1.6之前：永久代，常量池在方法区")]),s._v(" "),t("li",[s._v("JDK1.7：永久代，慢慢退化，去永久代，字符常量池在堆中，运行时常量池在方法区")]),s._v(" "),t("li",[s._v("JDK1.8之后：无永久代，字符常量池在堆中，运行时常量池在方法区（元空间）")]),s._v(" "),t("li",[s._v("一个启动类加载了大量的第三方jar包，Tomcat部署了太多的应用，或者大量动态生成的反射类，不断被加载可能导致OOM")])]),s._v(" "),t("h2",{attrs:{id:"堆内存调优"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆内存调优"}},[s._v("#")]),s._v(" 堆内存调优")]),s._v(" "),t("ul",[t("li",[s._v("出现OOM：\n"),t("ol",[t("li",[s._v("尝试扩大堆内存看结果")]),s._v(" "),t("li",[s._v("分析内存，看一下哪个地方出现了问题（使用专业工具）")])])]),s._v(" "),t("li",[s._v("-Xms：设置初始分配大小，默认为物理内存的1/64")]),s._v(" "),t("li",[s._v("-Xmx：最大分配内存，默认为物理内存的1/4\n"),t("ul",[t("li",[s._v("VM options：-Xms1024m -Xmx1024m -XX:+PrintGCDetails（"),t("strong",[s._v("打印GC垃圾回收信息")]),s._v("）")])])]),s._v(" "),t("li",[s._v("在一个项目中突然出现OOM故障，那么"),t("strong",[s._v("该如何排错，研究为什么出错")]),s._v(" "),t("ul",[t("li",[s._v("能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler")]),s._v(" "),t("li",[s._v("Dubug，一行行分析代码")])])]),s._v(" "),t("li",[t("strong",[s._v("MAT，Jprofiler作用：")]),s._v(" "),t("ul",[t("li",[s._v("分析Dump内存文件，快速定位内存泄露")]),s._v(" "),t("li",[s._v("获得堆中的数据")]),s._v(" "),t("li",[s._v("获得大的对象")])])]),s._v(" "),t("li",[s._v("使用Jprofiler工具Dump\n"),t("ul",[t("li",[s._v("先设置VM options参数：-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError（"),t("strong",[s._v("后面的错误为需要Dump的错误")]),s._v("）")])])])]),s._v(" "),t("h2",{attrs:{id:"gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc"}},[s._v("#")]),s._v(" GC")]),s._v(" "),t("ul",[t("li",[s._v("作用区：方法区和堆")]),s._v(" "),t("li",[s._v("JVM在进行GC时，并不是对这三个区域统一回收，大部分时候，回收都是新生代")]),s._v(" "),t("li",[s._v("GC两种类型：轻GC（普通GC），重GC（全局GC）")]),s._v(" "),t("li",[s._v("例题：\n"),t("ul",[t("li",[s._v("JVM的内存模型和分区，详细到每个区放什么？")]),s._v(" "),t("li",[s._v("堆里面的分区有哪些？Eden，from，to，老年区，说说他们的特点")]),s._v(" "),t("li",[s._v("GC的算法有哪些？四大算法：复制算法，标记整理算法，标记清除算法，分代收集算法，怎么用的？")]),s._v(" "),t("li",[s._v("轻GC和重GC分别在什么时候发生？")])])])]),s._v(" "),t("h3",{attrs:{id:"常用算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用算法"}},[s._v("#")]),s._v(" 常用算法")]),s._v(" "),t("h4",{attrs:{id:"复制算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#复制算法"}},[s._v("#")]),s._v(" 复制算法")]),s._v(" "),t("img",{staticStyle:{zoom:"67%"},attrs:{src:"/JVM.assets/复制算法.png",alt:"复制算法"}}),s._v(" "),t("ul",[t("li",[s._v("步骤：\n"),t("ul",[t("li",[s._v("每次"),t("strong",[s._v("存活的对象")]),s._v("，都会被"),t("strong",[s._v("从from区和Eden区等复制到to区")])]),s._v(" "),t("li",[s._v("from区和to区"),t("strong",[s._v("会发生一次交换")]),s._v("，"),t("strong",[s._v("谁空谁是to")])]),s._v(" "),t("li",[s._v("每当GC后幸存一次，就会导致这个对象的年龄+1，如果这个年龄值大于15(默认GC次数，可以修改)，就会进入养老区")])])]),s._v(" "),t("li",[s._v("通过-XX:MaxTenuringThreshold=5可以设定进入老年区需要活过GC的次数\n"),t("ul",[t("li",[s._v("只有4位用来储存这个参数，所以最大值为15")])])]),s._v(" "),t("li",[s._v("由于Eden区对象存活率极低，据统计99%对象都会在使用一次之后引用失效，因此在"),t("strong",[s._v("该区中推荐使用复制算法")])]),s._v(" "),t("li",[s._v("优点：\n"),t("ul",[t("li",[s._v("没有标记和清除的过程，效率高")]),s._v(" "),t("li",[s._v("不会产生内存碎片")])])]),s._v(" "),t("li",[s._v("缺点：\n"),t("ul",[t("li",[s._v("浪费了内存空间（一半的幸存区(to区)空间永远是空的）")])])])]),s._v(" "),t("h4",{attrs:{id:"标记清除法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标记清除法"}},[s._v("#")]),s._v(" 标记清除法")]),s._v(" "),t("img",{staticStyle:{zoom:"80%"},attrs:{src:"/JVM.assets/标记清除法.png",alt:"标记清除法"}}),s._v(" "),t("ul",[t("li",[s._v("扫描所有对象，"),t("strong",[s._v("对活着的对象进行标记")]),s._v("；然后清除掉没有标记的对象")]),s._v(" "),t("li",[s._v("优点：\n"),t("ul",[t("li",[s._v("不需要额外空间")])])]),s._v(" "),t("li",[s._v("缺点：\n"),t("ul",[t("li",[s._v("两次扫描严重浪费时间")]),s._v(" "),t("li",[s._v("会产生内存碎片（虚线框）")])])])]),s._v(" "),t("h4",{attrs:{id:"标记整理法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标记整理法"}},[s._v("#")]),s._v(" 标记整理法")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("也叫标记清除压缩法，是在标记清除法的基础上整理空间")]),s._v(" "),t("img",{staticStyle:{zoom:"80%"},attrs:{src:"/JVM.assets/标记整理法.png",alt:"标记整理法"}})]),s._v(" "),t("li",[t("p",[s._v("当一个空间很少发生GC，可以考虑使用此算法")])])]),s._v(" "),t("h4",{attrs:{id:"分代收集法-目前jvm使用的算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分代收集法-目前jvm使用的算法"}},[s._v("#")]),s._v(" 分代收集法（目前JVM使用的算法）")]),s._v(" "),t("ul",[t("li",[s._v("并不是一种新的算法，而是将堆分为新生代和老年代，根据区域特点选用不同的收集算法，如果新生代朝生夕死，则采用复制算法，老年代采用标记清除，或标记整理，"),t("strong",[s._v("回收次数相对较少，每次回收时间比较长")])])]),s._v(" "),t("h4",{attrs:{id:"引用计数法-一般不使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用计数法-一般不使用"}},[s._v("#")]),s._v(" 引用计数法（一般不使用）"),t("span",{attrs:{id:"yyjs"}})]),s._v(" "),t("p",[t("img",{attrs:{src:"/JVM.assets/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.png",alt:"引用计数法"}})]),s._v(" "),t("ul",[t("li",[s._v("给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的")]),s._v(" "),t("li",[s._v("实现简单，判定效率高，但不能解决循环引用问题")])]),s._v(" "),t("h4",{attrs:{id:"算法小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法小结"}},[s._v("#")]),s._v(" 算法小结")]),s._v(" "),t("ul",[t("li",[s._v("内存效率：复制算法>标记清除算法>标记整理算法")]),s._v(" "),t("li",[s._v("内存整齐度：复制算法=标记整理算法>标记清除算法")]),s._v(" "),t("li",[s._v("内存利用率：标记整理算法=标记清除算法>复制算法")]),s._v(" "),t("li",[s._v("从效率上来说，复制算法最好，但是空间浪费较多。为了兼顾所有的指标，标记整理算法会平滑一些，但是效率不尽如意")]),s._v(" "),t("li",[s._v("实际上，所有的算法，无非就是以空间换时间或者以时间换空间。没有最好的算法，只有最合适的算法。所以上面说的分代收集法，并不是指一种算法，而是指"),t("strong",[s._v("在不同的区域使用不同的算法")])])]),s._v(" "),t("h4",{attrs:{id:"gc查看对象是否存活的方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc查看对象是否存活的方法"}},[s._v("#")]),s._v(" GC查看对象是否存活的方法")]),s._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#yyjs"}},[s._v("引用计数法")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#kdxfx"}},[s._v("可达性分析法")]),s._v("（在主流的商用程序语言的主流实现中，都是通过可达性分析算法来判断对象是否存活的）")])]),s._v(" "),t("h3",{attrs:{id:"gc-root"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc-root"}},[s._v("#")]),s._v(" GC  Root")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("什么是垃圾？简单的说，就是"),t("strong",[s._v("不再被引用的对象")]),s._v("。如："),t("code",[s._v("Object object=null;")])]),s._v(" "),t("p",[t("span",{attrs:{id:"kdxfx"}})])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("可达性分析算法")]),s._v("：简单来说就是通过从GC Root这个对象开始一层层往下遍历，能够遍历到的对象就是可达的，不能被遍历到的对象就是不可达的，不可达对象就是要被回收的垃圾")]),s._v(" "),t("ul",[t("li",[s._v("若对象在进行可达性分析后发现没有与 GC roots 相连接的引用链，那么他将会被"),t("strong",[s._v("第一次标记并进行一次筛选")]),s._v("，筛选的条件是该对象是否有必要执行 finalize()方法，当对象没有重写finalize()方法或者 finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为没必要执行。")]),s._v(" "),t("li",[s._v("若该对象"),t("strong",[s._v("被判定为有必要执行 finalize方法")]),s._v("，则这个对象会被放在一个 F-Queue 队列，finalize方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-queue中的对象"),t("strong",[s._v("进行第二次小规模的标记")]),s._v("，若对象要在 finalize中成功拯救自己—次就要重新与引用链上的任何一个对象建立关联即可（即可"),t("strong",[s._v("以重写finalize()方法来实现")]),s._v("，比如可以将自己赋值给某个类变量或者对象的成员变量），那么在第二次标记时他们将会被移出“即将回收”集合。"),t("strong",[s._v("任何一个对象的 finalize()方法都只会被系统调用一次")])])])]),s._v(" "),t("li",[t("p",[s._v("可作为GC Root的对象")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("虚拟机栈中引用的对象")])]),s._v(" "),t("li",[t("strong",[s._v("类中静态属性引用的对象")])]),s._v(" "),t("li",[t("strong",[s._v("方法区中的常量")])]),s._v(" "),t("li",[t("strong",[s._v("本地方法栈中Native方法引用的对象")])]),s._v(" "),t("li",[s._v("对于数组，如果只是在类成员中进行定义而没有声明数组大小，不是GC Root；如果已经声明了数组大小，则是GC Root，因为此时它已经开辟了内存空间")]),s._v(" "),t("li",[s._v("对于静态成员对象属性，只要定义了，不管初始化值是null还是new出了对象，都是GC Root")])])]),s._v(" "),t("li",[t("p",[s._v("引用强度：强引用 > 软引用 > 弱引用 > 虚引用")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("强引用(StrongReference)：类似Object obj = new Object() 的引用，只要强引用还存在，垃圾收集器"),t("strong",[s._v("永远不会回收掉")]),s._v("被引用的对象。如果这个obj是全局的变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收")])]),s._v(" "),t("li",[t("p",[s._v("软引用(SoftReference)：用来。描述一些还有用但并非必须的对象。如果一个对象只具有软引用，则"),t("strong",[s._v("内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存")]),s._v("。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。SoftReference类实现软引用")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" str"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"abc"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("                                     "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 强引用")]),s._v("\n "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("SoftReference")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" softRef"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("SoftReference")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("str"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("     "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 软引用")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//当内存不足时，等价于：")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("If")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("JVM"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("内存不足"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n   str "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 转换为软引用")]),s._v("\n   "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("System")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("gc")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 垃圾回收器进行回收")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])])]),s._v(" "),t("li",[t("p",[s._v("弱引用(WeakReference)：用来描述非必须对象，但其强度比软引用更弱。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，"),t("strong",[s._v("不管当前内存空间足够与否，都会回收它的内存")]),s._v("。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。WeakReference类实现弱引用")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" str"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"abc"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//这条代码会让str再次变为一个强引用：String abc = abcWeakRef.get();")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("WeakReference")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" abcWeakRef "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("WeakReference")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("str"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nstr"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//当垃圾回收器进行扫描回收时等价于：")]),s._v("\nstr "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("System")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("gc")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br")])])]),s._v(" "),t("li",[t("p",[s._v("虚引用(PhantomReference)：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是"),t("strong",[s._v("能在这个对象被收集器回收时收到一个系统通知")]),s._v("。PhantomReference类实现虚引用")])])])])]),s._v(" "),t("h3",{attrs:{id:"gc的执行机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc的执行机制"}},[s._v("#")]),s._v(" GC的执行机制")]),s._v(" "),t("ul",[t("li",[s._v("Minor GC\n"),t("ul",[t("li",[s._v("一般情况下，当新对象生成，并且在Eden申请空间失败(Eden空间已满)时，就会触发Minor GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代")])])]),s._v(" "),t("li",[s._v("Full GC\n"),t("ul",[t("li",[s._v("Full GC因为需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节")]),s._v(" "),t("li",[s._v("有如下原因可能导致Full GC：\n"),t("ul",[t("li",[s._v("老年区被写满")]),s._v(" "),t("li",[s._v("方法区被写满")]),s._v(" "),t("li",[s._v("System.gc()被显示调用，系统建议执行Full GC，但是不必然执行")])])])])])]),s._v(" "),t("h3",{attrs:{id:"jmm-java-memory-model"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jmm-java-memory-model"}},[s._v("#")]),s._v(" JMM：Java Memory Model")]),s._v(" "),t("ol",[t("li",[s._v("什么是JMM？\n"),t("ul",[t("li",[s._v("Java Memory Model的缩写")]),s._v(" "),t("li",[s._v("JMM是一个抽象的概念")]),s._v(" "),t("li",[s._v("Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用\n"),t("ul",[t("li",[t("code",[s._v("volatile")]),s._v("、"),t("code",[s._v("synchronized")]),s._v("、"),t("code",[s._v("final")]),s._v("、"),t("code",[s._v("concurren")]),s._v("包等")])])])])]),s._v(" "),t("li",[s._v("它是干嘛的？\n"),t("ul",[t("li",[s._v("作用："),t("strong",[s._v("为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范")])]),s._v(" "),t("li",[s._v("JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存(Local Memory)")]),s._v(" "),t("li",[s._v("JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory），线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成\n"),t("ul",[t("li",[s._v("线程A与线程B之间如要通信的话，必须要经历下面2个步骤：\n"),t("ol",[t("li",[s._v("首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去")]),s._v(" "),t("li",[s._v("然后，线程B到主内存中去读取线程A之前已更新过的共享变量")])])]),s._v(" "),t("li",[s._v("JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证")])])])])])]),s._v(" "),t("ul",[t("li",[t("p",[s._v("volatile")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("volatile防止指令重排序规则")]),s._v(" "),t("ul",[t("li",[s._v("当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行")]),s._v(" "),t("li",[s._v("在进行指令优化时，"),t("strong",[s._v("不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行")])])])]),s._v(" "),t("li",[t("p",[s._v("原理")]),s._v(" "),t("ol",[t("li",[s._v("规定线程每次修改变量副本后"),t("strong",[s._v("立刻同步到主内存")]),s._v("中，用于保证其它线程可以看到自己对变量的修改")]),s._v(" "),t("li",[s._v("规定线程每次使用变量前，先从主内存中"),t("strong",[s._v("刷新最新的值")]),s._v("到工作内存，用于保证能看见其它线程对变量修改的最新值")]),s._v(" "),t("li",[s._v("为了实现可见性内存语义，编译器在生成字节码时，会在指令序列中插入"),t("strong",[s._v("内存屏障")]),s._v("来"),t("strong",[s._v("防止指令重排序")]),s._v("。")])])]),s._v(" "),t("li",[t("p",[s._v("volatile只能保证基本类型变量的内存可见性，对于引用类型，无法保证引用所指向的"),t("strong",[s._v("实际对象内部数据")]),s._v("的内存可见性")])]),s._v(" "),t("li",[t("p",[s._v("volilate只能保证共享对象的"),t("strong",[s._v("可见性")]),s._v("，不能保证"),t("strong",[s._v("原子性")]),s._v("：假设两个线程同时在做x++，在线程A修改共享变量从0到1的同时，线程B"),t("strong",[s._v("已经正在使用")]),s._v("值为0的变量，所以这时候"),t("strong",[s._v("可见性已经无法发挥作用")]),s._v("，线程B将其修改为1，所以最后结果是1而不是2")])]),s._v(" "),t("li",[t("p",[s._v("单例模式的双重锁为什么要加volatile")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("TestInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("private")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("volatile")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("TestInstance")]),s._v(" instance"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("TestInstance")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("getInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("       "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//1")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("                       "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//2")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("synchronized")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("TestInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("       "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//3")]),s._v("\n                "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("               "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//4")]),s._v("\n                    instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("TestInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//5")]),s._v("\n                "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" instance"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("                            "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//6")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br")])]),t("ul",[t("li",[t("p",[s._v("需要volatile关键字的原因是，在并发情况下，如果没有volatile关键字，在第5行会出现问题。instance = new TestInstance();可以分解为3行伪代码")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("a. memory = allocate() //分配内存\nb. ctorInstanc(memory) //初始化对象\nc. instance = memory   //设置instance指向刚分配的地址\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])])]),s._v(" "),t("li",[t("p",[s._v("上面的代码在编译运行时，可能会出现重排序从a-b-c排序为a-c-b。在多线程的情况下会出现以下问题。当线程A在执行第5行代码时，B线程进来执行到第2行代码。假设此时A执行的过程中发生了指令重排序，即先执行了a和c，没有执行b。那么由于A线程执行了c导致instance指向了一段地址，所以B线程判断instance不为null，会直接跳到第6行并返回一个未初始化的对象")])])])])])])])])}),[],!1,null,null,null);a.default=n.exports}}]);