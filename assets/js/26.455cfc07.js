(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{471:function(v,t,_){"use strict";_.r(t);var s=_(20),a=Object(s.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"框架"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#框架"}},[v._v("#")]),v._v(" 框架")]),v._v(" "),_("h2",{attrs:{id:"spring是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring是什么"}},[v._v("#")]),v._v(" spring是什么")]),v._v(" "),_("ul",[_("li",[v._v("轻量级的开源的J2EE框架。它是一个容器框架，用来装 java bean (java对象)，中间层框架(万能胶)可以起一个连接作用，比如说把Struts和hibernate粘合在一起运用，可以让我们的企业开发更快、更简洁")]),v._v(" "),_("li",[v._v("Spring"),_("strong",[v._v("是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架")]),v._v(" "),_("ul",[_("li",[v._v("从大小与开销两方面而言Spring都是轻量级的")]),v._v(" "),_("li",[_("strong",[v._v("通过控制反转(IoC)的技术达到松耦合的目的")])]),v._v(" "),_("li",[_("strong",[v._v("提供了面向切面编程的丰富支持")]),v._v("，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发")]),v._v(" "),_("li",[v._v("包含并管理应用对象(Bean)的配置和生命周期，这个意义上是一个容器")]),v._v(" "),_("li",[v._v("将简单的组件配置、组合成为复杂的应用，这个意义上是一个框架")])])])]),v._v(" "),_("h2",{attrs:{id:"spring中bean是线程安全的吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring中bean是线程安全的吗"}},[v._v("#")]),v._v(" Spring中Bean是线程安全的吗")]),v._v(" "),_("ul",[_("li",[v._v("Spring"),_("strong",[v._v("本身并没有针对Bean做线程安全的处理")]),v._v("，所以：\n"),_("ol",[_("li",[v._v("如果Bean是"),_("strong",[v._v("无状态")]),v._v("对象(Stateless Bean)，就是"),_("strong",[v._v("没有实例变量的对象，不能保存数据，是不变类")]),v._v("，是"),_("strong",[v._v("线程安全")]),v._v("的")]),v._v(" "),_("li",[v._v("如果Bean是"),_("strong",[v._v("有状态")]),v._v("对象(Stateful Bean)，就是"),_("strong",[v._v("有实例变量的对象 ，可以保存数据")]),v._v("，是"),_("strong",[v._v("非线程安全")]),v._v("的")])])]),v._v(" "),_("li",[v._v("另外，"),_("strong",[v._v("Bean是不是线程安全，跟Bean的作用域没有关系")]),v._v("，Bean的作用域只是表示Bean的生命周期范围，对于任何生命周期的Bean都是一个对象，这个"),_("strong",[v._v("对象是不是线程安全的，还是得看这个Bean对象本身")])])]),v._v(" "),_("h2",{attrs:{id:"spring的事务机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring的事务机制"}},[v._v("#")]),v._v(" Spring的事务机制")]),v._v(" "),_("ol",[_("li",[v._v("Spring事务"),_("strong",[v._v("底层是基于数据库事务和AOP机制")]),v._v("的")]),v._v(" "),_("li",[v._v("首先"),_("strong",[v._v("对于使用了"),_("code",[v._v("@Transactional")]),v._v("注解的Bean，Spring会创建一个Bean的代理对象")])]),v._v(" "),_("li",[v._v("当"),_("strong",[v._v("调用代理对象的方法")]),v._v("时，会"),_("strong",[v._v("先判断该方法上是否加了"),_("code",[v._v("@Transactional")]),v._v("注解")])]),v._v(" "),_("li",[v._v("如果加了，那么则利用事务管理器"),_("strong",[v._v("创建一个数据库连接")])]),v._v(" "),_("li",[v._v("并且修改数据库连接的"),_("code",[v._v("autocommit")]),v._v("属性为false，"),_("strong",[v._v("禁止此连接的自动提交")]),v._v("，这是实现Spring事务非常重要的一步")]),v._v(" "),_("li",[v._v("然后"),_("strong",[v._v("执行当前方法")]),v._v("，方法中会"),_("strong",[v._v("执行sql")])]),v._v(" "),_("li",[v._v("执行完当前方法后，如果"),_("strong",[v._v("没有出现异常就直接提交事务")])]),v._v(" "),_("li",[v._v("如果"),_("strong",[v._v("出现了异常")]),v._v("，并且这个"),_("strong",[v._v("异常是需要回滚的就会回滚事务，否则仍然提交事务")])]),v._v(" "),_("li",[_("strong",[v._v("Spring事务的隔离级别对应的就是数据库的隔离级别")])]),v._v(" "),_("li",[_("strong",[v._v("Spring事务的传播机制是Spring事务自己实现的")]),v._v("，也是Spring事务中最复杂的")]),v._v(" "),_("li",[v._v("Spring事务的传播机制是"),_("strong",[v._v("基于数据库连接来做的")]),v._v("，一个数据库连接一个事务，如果"),_("strong",[v._v("传播机制配置为需要新开一个事务")]),v._v("，那么"),_("strong",[v._v("实际上就是先建立一个数据库连接")]),v._v("，在此新数据库连接上执行sql")])]),v._v(" "),_("h2",{attrs:{id:"什么时候-transactional会失效"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么时候-transactional会失效"}},[v._v("#")]),v._v(" 什么时候@Transactional会失效")]),v._v(" "),_("ul",[_("li",[v._v("因为Spring事务是"),_("strong",[v._v("基于代理来实现的")]),v._v("，所以某个加了"),_("code",[v._v("@Transactional")]),v._v("的方法"),_("strong",[v._v("只有是代理对象调用时，那么这个注解才会生效")]),v._v("，所以所以如果是"),_("strong",[v._v("真实对象来调用")]),v._v("这个方法，那么"),_("code",[v._v("@Transactional")]),v._v("是"),_("strong",[v._v("不会生效")]),v._v("的")]),v._v(" "),_("li",[_("code",[v._v("@Transactional")]),v._v("注解"),_("strong",[v._v("只能应用到public修饰符上，其它修饰符不会获取"),_("code",[v._v("@Transactional")]),v._v("的属性配置信息")]),v._v("，不会起作用，且"),_("strong",[v._v("不会有任何报错")])]),v._v(" "),_("li",[_("code",[v._v("@Transactional")]),v._v("配置有错误")]),v._v(" "),_("li",[v._v("数据库引擎不支持事务")]),v._v(" "),_("li",[_("strong",[v._v("同一个类中方法调用")]),v._v("，导致@Transactional失效：开发中避免不了会对"),_("strong",[v._v("同一个类里面的方法调用")]),v._v("，比如有一个类Test，它的一个方法A，"),_("strong",[v._v("A再调用本类的方法B")]),v._v("（不论方法B是用public还是private修饰），但"),_("strong",[v._v("方法A没有声明注解事务")]),v._v("，而"),_("strong",[v._v("B方法有")]),v._v("。则外部调用方法A之后，"),_("strong",[v._v("方法B的事务是不会起作用的")])])]),v._v(" "),_("h2",{attrs:{id:"spring事务回滚失败的场景-接上题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring事务回滚失败的场景-接上题"}},[v._v("#")]),v._v(" Spring事务回滚失败的场景 (接上题)")]),v._v(" "),_("ul",[_("li",[v._v("Spring的默认事务机制，当出现unchecked异常时候回滚，checked异常的时候不会回滚。异常中unchecked异常包括error和runtime异常。需要try catch或向上抛出的异常，为checked异常比如IOException，也就是说"),_("strong",[v._v("程序抛出runtime异常的时候才会进行回滚，其他异常不回滚")])]),v._v(" "),_("li",[v._v("可以配置设置"),_("strong",[v._v("所有异常回滚")]),v._v("："),_("code",[v._v("@Transactional(rollbackFor = { Exception.class })")])])]),v._v(" "),_("p",[v._v("当有"),_("code",[v._v("try catch")]),v._v("后"),_("strong",[v._v("捕获了异常，事务不会回滚")]),v._v("。如果不得不在service层写"),_("code",[v._v("try catch")]),v._v(" 需要catch后"),_("strong",[v._v("手动抛一个运行时异常")]),_("code",[v._v("throw new RuntimeException")]),v._v("让事务回滚")]),v._v(" "),_("h2",{attrs:{id:"spring中后置处理器的作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring中后置处理器的作用"}},[v._v("#")]),v._v(" Spring中后置处理器的作用")]),v._v(" "),_("ul",[_("li",[v._v("Spring中的后置处理器分为BeanFactory后置处理器和Bean后置处理器，它们是Spring底层源码架构设计中非常重要的一种机制，同时"),_("strong",[v._v("开发者也可以利用这两种后置处理器来进行扩展")]),v._v("。BeanFactory后置处理器表示针对BeanFactory的处理器，Spring启过程中，会先创建出BeanFactory实例，然后利用BeanFactory处理器来加工BeanFactory， 比如"),_("strong",[v._v("Spring的扫描就是基于BeanFactory后置处理器来实现的")]),v._v("，而Bean后置处理器也类似，Spring在创建一个Bean的过程中，首先会实例化得到一个对象，然后再"),_("strong",[v._v("利用Bean后置处理器来对该实例对象进行加工")]),v._v("，比如我们常说的"),_("strong",[v._v("依赖注入就是基于一个Bean后置处理器来实现的")]),v._v("，通过该Bean后置处理器来给实例对象中加了@Autowired注解的属性自动赋值，还比如我们常说的"),_("strong",[v._v("AOP，也是利用一个Bean后置处理器来实现的")]),v._v("，基于原实例对象，判断是否需要进行AOP，如果需要，那么就基于原实例对象进行动态代理。生成一个代理对象")])]),v._v(" "),_("h2",{attrs:{id:"spring如何解决循环依赖以及三级缓存概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring如何解决循环依赖以及三级缓存概念"}},[v._v("#")]),v._v(" Spring如何解决循环依赖以及三级缓存概念")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Spring循环依赖的理论依据其实是"),_("strong",[v._v("Java基于引用传递")]),v._v("，当我们"),_("strong",[v._v("获取到对象的引用时")]),v._v("，对象的"),_("strong",[v._v("field或者或属性是可以延后设置")]),v._v("的")])]),v._v(" "),_("li",[_("p",[v._v("Spring单例对象的初始化其实可以分为三步：("),_("strong",[v._v("实例化、填充属性、初始化")]),v._v(")")])]),v._v(" "),_("li",[_("p",[v._v("对于"),_("strong",[v._v("单例对象")]),v._v("来说，在Spring的整个容器的生命周期内，有且只存在一个对象，这个"),_("strong",[v._v("对象存在Cache")]),v._v('中，Spring大量运用了Cache的手段，在循环依赖问题的解决过程中甚至使用了"三级缓存"')]),v._v(" "),_("div",{staticClass:"language-java line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("/** Cache of singleton objects: bean name --\x3e bean instance */")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("private")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("final")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Map")]),_("span",{pre:!0,attrs:{class:"token generics"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("String")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Object")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),v._v(" singletonObjects "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("ConcurrentHashMap")]),_("span",{pre:!0,attrs:{class:"token generics"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("String")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Object")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("256")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("/** Cache of early singleton objects: bean name --\x3e bean instance */")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("private")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("final")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Map")]),_("span",{pre:!0,attrs:{class:"token generics"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("String")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Object")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),v._v(" earlySingletonObjects "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("HashMap")]),_("span",{pre:!0,attrs:{class:"token generics"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("String")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Object")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("16")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("/** Cache of singleton factories: bean name --\x3e ObjectFactory */")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("private")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("final")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Map")]),_("span",{pre:!0,attrs:{class:"token generics"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("String")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("ObjectFactory")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("?")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),v._v(" singletonFactories "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("HashMap")]),_("span",{pre:!0,attrs:{class:"token generics"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("String")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("ObjectFactory")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("?")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("16")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br"),_("span",{staticClass:"line-number"},[v._v("7")]),_("br"),_("span",{staticClass:"line-number"},[v._v("8")]),_("br")])])]),v._v(" "),_("li",[_("p",[v._v("Spring用这三级缓存巧妙的解决了循环依赖问题")]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("singletonObjects")]),v._v("一级缓存，用于"),_("strong",[v._v("保存实例化、注入、初始化完成的bean实例")])])]),v._v(" "),_("li",[_("p",[_("code",[v._v("earlySingletonObjects")]),v._v("二级缓存，用于"),_("strong",[v._v("保存实例化完成的bean实例")])])]),v._v(" "),_("li",[_("p",[_("code",[v._v("singletonFactories")]),v._v("三级缓存，用于"),_("strong",[v._v("保存bean创建工厂")]),v._v("，以便于后面"),_("strong",[v._v("扩展有机会创建代理对象")])]),v._v(" "),_("p",[_("img",{attrs:{src:"/%E9%9D%A2%E8%AF%95%E9%A2%98.assets/giuIlH-DkGpSm.png",alt:"img"}})]),v._v(" "),_("p",[_("img",{attrs:{src:"/%E9%9D%A2%E8%AF%95%E9%A2%98.assets/v2-3b51599307d1477725afed3e091b7f09_r.jpg",alt:"img"}})]),v._v(" "),_("p",[_("img",{attrs:{src:"/%E9%9D%A2%E8%AF%95%E9%A2%98.assets/v2-ea18dddbbf6c5626890c007eca9df23a_r.jpg",alt:"img"}})])]),v._v(" "),_("li",[_("p",[v._v("第三级缓存中为什么要添加"),_("code",[v._v("ObjectFactory")]),v._v("对象，直接保存实例对象不行吗？")]),v._v(" "),_("ul",[_("li",[v._v("不行，因为假如你想对添加到三级缓存中的实例对象进行增强，直接用实例对象是行不通的")]),v._v(" "),_("li",[v._v("或者所有对象都得被代理一遍")])])]),v._v(" "),_("li",[_("p",[v._v("假设去掉二级缓存")]),v._v(" "),_("ul",[_("li",[v._v("如果去掉了二级缓存，则需要直接在 "),_("code",[v._v("singletonFactory.getObject()")]),v._v("三级缓存阶段初始化完毕，并放到一级缓存中")]),v._v(" "),_("li",[v._v("那有这么一种场景，B 和 C 都依赖了 A。要知道在有代理的情况下 "),_("code",[v._v("singletonFactory.getObject()")]),v._v(" 获取的是代理对象")]),v._v(" "),_("li",[v._v("而"),_("strong",[v._v("多次调用 "),_("code",[v._v("singletonFactory.getObject()")]),v._v(" 返回的代理对象是不同的")]),v._v("，就会"),_("strong",[v._v("导致 B 和 C 依赖了不同的 A")])])])])])])]),v._v(" "),_("h2",{attrs:{id:"spring创建bean对象的三种方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring创建bean对象的三种方式"}},[v._v("#")]),v._v(" Spring创建bean对象的三种方式")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("通过构造器(有参或无参)")]),v._v(" "),_("ul",[_("li",[v._v("方式："),_("code",[v._v('<bean id="" class=""/>')])])])]),v._v(" "),_("li",[_("p",[v._v("通过静态工厂方法")]),v._v(" "),_("ul",[_("li",[v._v("方式："),_("code",[v._v('<bean id="" class="工厂类" factory-method="静态工厂方法"/>')])]),v._v(" "),_("li",[v._v("注：工厂类实例没有创建")])])]),v._v(" "),_("li",[_("p",[v._v("通过实例工厂方法(非静态方法)")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("方式：")]),v._v(" "),_("div",{staticClass:"language-java line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("bean id"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"factory"')]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("class")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"工厂类"')]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("/")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("bean id"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('""')]),v._v(" factory"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("bean"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"factory"')]),v._v(" factory"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("method"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"实例工厂方法"')]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("/")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br")])])]),v._v(" "),_("li",[_("p",[v._v("注：工厂类实例被创建")])])])])]),v._v(" "),_("h2",{attrs:{id:"spring创建bean-jvm创建类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring创建bean-jvm创建类"}},[v._v("#")]),v._v(" Spring创建bean，JVM创建类")]),v._v(" "),_("ul",[_("li",[v._v("spring：实例化->依赖注入->初始化")]),v._v(" "),_("li",[v._v("JVM：加载->连接 (验证->准备->解析) ->初始化")]),v._v(" "),_("li",[v._v("其中spring bean 的"),_("strong",[v._v("实例化")]),v._v("就包含了JVM对一个类的实例化过程")])]),v._v(" "),_("h2",{attrs:{id:"说说常用的springboot注解-及其实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#说说常用的springboot注解-及其实现"}},[v._v("#")]),v._v(" 说说常用的SpringBoot注解，及其实现")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("@SpringBootApplication")]),v._v("注解：这个注解"),_("strong",[v._v("标识了一个SpringBoot工程")]),v._v("，它实际上是另外三个注解的组合，这三个注解是：\n"),_("ol",[_("li",[_("code",[v._v("@SpringBootConfiguration")]),v._v("：这个注解实际就是一个"),_("code",[v._v("@Configuration")]),v._v("，"),_("strong",[v._v("表示启动类也是一个配置类")])]),v._v(" "),_("li",[_("code",[v._v("@EnableAutoConfiguration")]),v._v("："),_("strong",[v._v("启动自动装配")]),v._v("，向Spring容器中导入了一个Selector，"),_("strong",[v._v("用来加载ClassPath下SpringFactories中所定义的自动配置类")]),v._v("，将这些自动加载为配置Bean")]),v._v(" "),_("li",[_("code",[v._v("@ComponentScan")]),v._v("："),_("strong",[v._v("标识扫描路径")]),v._v("，因为默认是没有配置实际扫描路径，所以SpringBoot扫描的路径是"),_("strong",[v._v("启动类所在的当前目录")])])])]),v._v(" "),_("li",[_("code",[v._v("@Bean")]),v._v("注解："),_("strong",[v._v("用来定义Bean")]),v._v("，类似于XML中的"),_("code",[v._v("<bean>")]),v._v("标签，Spring在启动时，会对加了@Bean注解的方法进行解析，将方法的名字做为beanName，并通过执行方法得到bean对象")]),v._v(" "),_("li",[_("code",[v._v("@Controller、@Service、@ResponseBody、@Autowired")]),v._v("都可以说")])]),v._v(" "),_("h2",{attrs:{id:"数据库隔离的四个级别分别为"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库隔离的四个级别分别为"}},[v._v("#")]),v._v(" 数据库隔离的四个级别分别为")]),v._v(" "),_("ul",[_("li",[v._v("Read Uncommitted（"),_("strong",[v._v("读取未提交内容")]),v._v("）\n"),_("ul",[_("li",[v._v("在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）")])])]),v._v(" "),_("li",[v._v("Read Committed（"),_("strong",[v._v("读取提交内容")]),v._v("）\n"),_("ul",[_("li",[v._v("这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果")])])]),v._v(" "),_("li",[v._v("Repeatable Read（"),_("strong",[v._v("可重读")]),v._v("）\n"),_("ul",[_("li",[v._v("这是"),_("strong",[v._v("MySQL的默认事务隔离级别")]),v._v("，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题")])])]),v._v(" "),_("li",[v._v("Serializable（"),_("strong",[v._v("可串行化")]),v._v("）\n"),_("ul",[_("li",[v._v("这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争")])])]),v._v(" "),_("li",[v._v("下表为事务的隔离级别与"),_("strong",[v._v("可能会引发的并发问题")])])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("事务隔离级别")]),v._v(" "),_("th",[v._v("脏读")]),v._v(" "),_("th",[v._v("不可重复读")]),v._v(" "),_("th",[v._v("幻读")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("读未提交(read-uncommitted)")]),v._v(" "),_("td",[v._v("是")]),v._v(" "),_("td",[v._v("是")]),v._v(" "),_("td",[v._v("是")])]),v._v(" "),_("tr",[_("td",[v._v("读提交(read-committed)")]),v._v(" "),_("td",[v._v("否")]),v._v(" "),_("td",[v._v("是")]),v._v(" "),_("td",[v._v("是")])]),v._v(" "),_("tr",[_("td",[v._v("可重复读(repeatable-read)")]),v._v(" "),_("td",[v._v("否")]),v._v(" "),_("td",[v._v("否")]),v._v(" "),_("td",[v._v("是")])]),v._v(" "),_("tr",[_("td",[v._v("可串行化(serializable)")]),v._v(" "),_("td",[v._v("否")]),v._v(" "),_("td",[v._v("否")]),v._v(" "),_("td",[v._v("否")])])])]),v._v(" "),_("h2",{attrs:{id:"聚集索引和非聚集索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#聚集索引和非聚集索引"}},[v._v("#")]),v._v(" 聚集索引和非聚集索引")]),v._v(" "),_("ul",[_("li",[v._v("聚集索引："),_("strong",[v._v("聚集索引确定表中数据在磁盘上的物理顺序")]),v._v("。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，"),_("strong",[v._v("因此一个表只能包含一个聚集索引")])]),v._v(" "),_("li",[v._v("非聚集索引：该索引中"),_("strong",[v._v("索引的逻辑顺序与磁盘上行的物理存储顺序不同")])]),v._v(" "),_("li",[v._v("非聚集索引和聚集索引的区别在于， "),_("strong",[v._v("通过聚集索引可以查到需要查找的数据")]),v._v("， 而"),_("strong",[v._v("通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据")])])]),v._v(" "),_("h2",{attrs:{id:"mysql引擎之innodb"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql引擎之innodb"}},[v._v("#")]),v._v(" MySQL引擎之innodb")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("特点：")]),v._v(" "),_("ol",[_("li",[v._v("支持事务，"),_("strong",[v._v("支持4个事务隔离级别，支持MVCC")]),v._v(" (多版本并发控制：把数据库的行锁与行的多个版本结合起来，实现并发控制)")]),v._v(" "),_("li",[_("strong",[v._v("行级锁定")]),v._v("（更新时一般是锁定当前行），"),_("strong",[v._v("通过索引实现")]),v._v("，但"),_("strong",[v._v("全表扫描仍然会是表锁")]),v._v("，注意间隙锁的影响")]),v._v(" "),_("li",[v._v("读写阻塞与事务隔离级别相关")]),v._v(" "),_("li",[v._v("具有非常高效的缓存特性："),_("strong",[v._v("能缓存索引，也能缓存数据")])]),v._v(" "),_("li",[v._v("整个表和"),_("strong",[v._v("主键以Cluster方式存储，组成一个平衡树")])]),v._v(" "),_("li",[v._v("所有Secondary Index都会保存主键信息")]),v._v(" "),_("li",[v._v("支持分区，表空间，类似oracle数据库")]),v._v(" "),_("li",[v._v("支持外键约束，5.5之前不支持全文索引，5.5之后支持外键索引")]),v._v(" "),_("li",[v._v("和Myisam引擎比，Innodb"),_("strong",[v._v("对硬件资源要求比较高")])])])])]),v._v(" "),_("h2",{attrs:{id:"innodb是如何实现事务的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#innodb是如何实现事务的"}},[v._v("#")]),v._v(" Innodb是如何实现事务的")]),v._v(" "),_("ul",[_("li",[v._v("Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务，以一个update语句为例：\n"),_("ol",[_("li",[v._v("Innodb在收到一个update语句后，会"),_("strong",[v._v("先根据条件找到数据所在的页(行)，并将该页缓存在Buffer Pool中")])]),v._v(" "),_("li",[v._v("执行update语句，"),_("strong",[v._v("修改Buffer Pool中的数据")]),v._v("，也就是"),_("strong",[v._v("内存")]),v._v("中的数据")]),v._v(" "),_("li",[v._v("针对update语句"),_("strong",[v._v("生成一个RedoLog对象")]),v._v("，并"),_("strong",[v._v("存入LogBuffer中")])]),v._v(" "),_("li",[v._v("针对update语句"),_("strong",[v._v("生成undolog日志，用于事务回滚")])]),v._v(" "),_("li",[v._v("如果"),_("strong",[v._v("事务提交")]),v._v("，那么则"),_("strong",[v._v("把RedoLog对象进行持久化")]),v._v("，后续"),_("strong",[v._v("还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中")])]),v._v(" "),_("li",[v._v("如果"),_("strong",[v._v("事务回滚")]),v._v("，则"),_("strong",[v._v("利用undolog日志进行回滚")])])])]),v._v(" "),_("li",[v._v("页是InnoDB存储引擎管理数据库的"),_("strong",[v._v("最小磁盘单位")]),v._v("。页类型为B-tree node的页，存放的即是表中行的实际数据了")]),v._v(" "),_("li",[v._v("简单来说：\n"),_("ol",[_("li",[v._v("收到update语句后，先"),_("strong",[v._v("根据条件找到数据所在的页(行)，并将该页缓存在内存中")])]),v._v(" "),_("li",[v._v("然后执行update语句，"),_("strong",[v._v("修改缓存中的数据")])]),v._v(" "),_("li",[v._v("再针对update语句"),_("strong",[v._v("生成一个对象，存入日志缓存中")])]),v._v(" "),_("li",[v._v("再"),_("strong",[v._v("生成一个用于事务回滚的日志")])]),v._v(" "),_("li",[v._v("如果事务"),_("strong",[v._v("提交")]),v._v("，就"),_("strong",[v._v("把语句生成的对象持久化")])]),v._v(" "),_("li",[v._v("如果事务"),_("strong",[v._v("回滚")]),v._v("，则"),_("strong",[v._v("利用生成的回滚日志进行回滚")])])])])]),v._v(" "),_("h2",{attrs:{id:"多版本并发控制mvcc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多版本并发控制mvcc"}},[v._v("#")]),v._v(" 多版本并发控制MVCC")]),v._v(" "),_("ul",[_("li",[v._v("MVCC (Multi-Version Concurrency Control) 是InnoDB实现隔离级别的一种方式，用于实现读取已提交和可重复读两种隔离级别")]),v._v(" "),_("li",[v._v("大多数事务型存储引擎实现都不是简单的行锁，基于并发性的考虑，一般会同时实现多版本并发控制（MVCC）处理读写冲突")]),v._v(" "),_("li",[v._v("MVCC是"),_("strong",[v._v("乐观锁的一种实现")]),v._v("，是通过"),_("strong",[v._v("保存数据在某一个时间点的快照")]),v._v("实现的，"),_("strong",[v._v("写操作更新最新的版本，读操作读取旧版本")])]),v._v(" "),_("li",[v._v("MVCC中事务的"),_("strong",[v._v("修改操作")]),v._v("（增删改）会为行记录"),_("strong",[v._v("新增一个版本快照")]),v._v("，并把当前事务id写入trx_id")]),v._v(" "),_("li",[v._v("在可重复读的隔离级别下，Innodb使用MVCC和next-key locks解决幻读，"),_("strong",[v._v("MVCC解决的是普通读（快照读）的幻读，next-key locks解决的是当前读情况下的幻读")]),v._v(" "),_("ul",[_("li",[v._v("普通读：普通的不加锁的select就是快照读。通过readview实现，可重复读级别时，整个事务的普通select都是使用同一个readview")]),v._v(" "),_("li",[v._v("当前读：读取最新版本已提交的数据。就算其他事务版本大于当前事务，但其他事务只要提交了的数据，当前事务使用当前读是可以读取到其他事务提交的数据的。"),_("strong",[v._v("在可重复读的事务隔离级别下，数据库会使用next-key locks来锁住本条记录以及索引区间")])])])])]),v._v(" "),_("h2",{attrs:{id:"cas-会引起的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cas-会引起的问题"}},[v._v("#")]),v._v(" CAS 会引起的问题")]),v._v(" "),_("ul",[_("li",[v._v("ABA 问题\n"),_("ul",[_("li",[v._v("比如说一个线程 one 从内存位置 V 中取出 A ，这时另外一个线程 two 也从内存中取出 A ，并且 two 进行了一些操作变成了 B ，然后 two 又将 V 位置的数据变成 A，这时线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功，但是，A 已经不再是原来的 A ，可能存在一些潜在的问题")]),v._v(" "),_("li",[v._v("java使用原子引用解决ABA问题\n"),_("ul",[_("li",[v._v("在原子引用上使用带时间戳的原子引用类。即"),_("code",[v._v("AtomicStampedReference")]),v._v("类")])])]),v._v(" "),_("li",[v._v("redis中的CAS已经通过判断数据版本解决了ABA问题")])])]),v._v(" "),_("li",[v._v("循环时间长开销大\n"),_("ul",[_("li",[v._v("CAS"),_("strong",[v._v("自旋的概率比较大")]),v._v("，从而浪费更多的 CPU 资源，效率可能低于synchronized")])])]),v._v(" "),_("li",[v._v("只能保证一个共享变量的原子操作\n"),_("ul",[_("li",[v._v("当对一个共享变量执行操作时，我们可以使用循环 CAS 的发方式来保证原子操作，但是对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁")])])])]),v._v(" "),_("h2",{attrs:{id:"什么是copyonwrite容器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是copyonwrite容器"}},[v._v("#")]),v._v(" 什么是CopyOnWrite容器")]),v._v(" "),_("ul",[_("li",[v._v("CopyOnWrite容器即写时复制的容器。通俗的理解是"),_("strong",[v._v("当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器")]),v._v("。这样做的好处是我们"),_("strong",[v._v("可以对CopyOnWrite容器进行并发的读，而不需要加锁")]),v._v("，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器")]),v._v(" "),_("li",[v._v("读的时候不需要加锁，如果读的时候有多个线程正在向"),_("code",[v._v("CopyOnWriteArrayList")]),v._v("添加数据，读还是会读到旧的数据，因为开始读的那一刻已经确定了读的对象是旧对象。CopyOnWrite并发容器"),_("strong",[v._v("适用于读多写少的并发场景")])]),v._v(" "),_("li",[_("code",[v._v("CopyOnWriteArrayList")]),_("strong",[v._v("读取时不加锁，只是写入、删除、修改时加锁")])]),v._v(" "),_("li",[v._v("CopyOnWrite的缺点\n"),_("ul",[_("li",[_("strong",[v._v("内存占用问题")]),v._v("。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象")]),v._v(" "),_("li",[_("strong",[v._v("数据一致性问题")]),v._v("。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。"),_("strong",[v._v("当执行add或remove操作没完成时，get获取的仍然是旧数组的元素")])])])])]),v._v(" "),_("h2",{attrs:{id:"synchronized锁升级的原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#synchronized锁升级的原理"}},[v._v("#")]),v._v(" synchronized锁升级的原理")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("锁")]),v._v(" "),_("th",[v._v("优点")]),v._v(" "),_("th",[v._v("缺点")]),v._v(" "),_("th",[v._v("适用场景")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("偏向锁")]),v._v(" "),_("td",[v._v("加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距")]),v._v(" "),_("td",[v._v("如果线程间存在锁竞争，会带来额外的锁撤销的消耗")]),v._v(" "),_("td",[v._v("适用于只有一个线程访问同步块场景")])]),v._v(" "),_("tr",[_("td",[v._v("轻量级锁")]),v._v(" "),_("td",[v._v("竞争的线程不会阻塞，提高了程序的响应速度")]),v._v(" "),_("td",[v._v("如果始终得不到锁竞争的线程使用自旋会消耗CPU")]),v._v(" "),_("td",[v._v("追求响应时间。同步块执行速度非常快")])]),v._v(" "),_("tr",[_("td",[v._v("重量级锁")]),v._v(" "),_("td",[v._v("线程竟争不使用自旋，不会消耗CPU")]),v._v(" "),_("td",[v._v("线程阻塞，响应时间缓慢")]),v._v(" "),_("td",[v._v("追求吞吐量。同步块执行速度较长")])])])]),v._v(" "),_("ul",[_("li",[v._v("所谓的锁升级、降级，就是 JVM 优化 synchronized 运行的机制，"),_("strong",[v._v("当 JVM 监测到不同的竞争状况时")]),v._v("，会自动切换到不同的锁实现。这种切换就是锁的升级、降级")]),v._v(" "),_("li",[v._v("当没有竞争出现时，"),_("strong",[v._v("默认会使用偏向锁")]),v._v("。JVM 会"),_("strong",[v._v("利用 CAS 操作")]),v._v("（compare and swap），在"),_("strong",[v._v("对象头上的 Mark Word 部分设置线程 ID")]),v._v("，以"),_("strong",[v._v("表示这个对象偏向于当前线程")]),v._v("，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，"),_("strong",[v._v("使用偏向锁可以降低无竞争开销")]),v._v("。如果"),_("strong",[v._v("有另外的线程试图锁定某个已经被偏向过的对象，JVM 就需要撤销（revoke）偏斜锁")]),v._v("，并"),_("strong",[v._v("切换到轻量级锁")]),v._v("实现。轻量级锁"),_("strong",[v._v("依赖 CAS 操作 Mark Word 来试图获取锁")]),v._v("，如果重试成功，就使用普通的轻量级锁；否则"),_("strong",[v._v("自旋一定次数后，进一步升级为重量级锁")])])]),v._v(" "),_("h2",{attrs:{id:"公平锁和非公平锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#公平锁和非公平锁"}},[v._v("#")]),v._v(" 公平锁和非公平锁")]),v._v(" "),_("ul",[_("li",[v._v("简单的来说，"),_("strong",[v._v("公平锁的含义就是谁等的时间最长，谁就先获取锁")]),v._v("，"),_("strong",[v._v("非公平锁")]),v._v("那就"),_("strong",[v._v("随机的获取")]),v._v("，谁运气好，CPU时间片轮到哪个线程，哪个线程就能获取锁")]),v._v(" "),_("li",[v._v("那如何能保证每个线程都能拿到锁呢，"),_("strong",[v._v("队列FIFO是一个完美的解决方案，也就是先进先出")]),v._v("，java的"),_("code",[v._v("ReenTrantLock")]),v._v("也就是用队列实现的公平锁和非公平锁")]),v._v(" "),_("li",[v._v("优缺点：\n"),_("ul",[_("li",[v._v("非公平锁性能高于公平锁性能。首先，在"),_("strong",[v._v("恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟")]),v._v("。而且，"),_("strong",[v._v("非公平锁能更充分的利用CPU的时间片")]),v._v("，尽量的减少CPU空闲的状态时间")])])]),v._v(" "),_("li",[v._v("使用场景：\n"),_("ul",[_("li",[v._v("如果业务中"),_("strong",[v._v("线程占用(处理)时间要远长于线程等待")]),v._v("，那用"),_("strong",[v._v("非公平锁其实效率并不明显")]),v._v("，但是"),_("strong",[v._v("用公平锁会给业务增强很多的可控制性")])])])])]),v._v(" "),_("h2",{attrs:{id:"什么是自动装箱和拆箱"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是自动装箱和拆箱"}},[v._v("#")]),v._v(" 什么是自动装箱和拆箱")]),v._v(" "),_("ul",[_("li",[v._v("在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行"),_("code",[v._v("Integer i = new Integer(10);")])]),v._v(" "),_("li",[v._v("而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了"),_("code",[v._v("Integer i = 10;")])]),v._v(" "),_("li",[v._v("这个过程会自动根据数值的类型创建Integer对象，则就是"),_("strong",[v._v("自动装箱")]),v._v("，同理\n"),_("ul",[_("li",[_("code",[v._v("Integer i = 10;\tint j = i;")]),v._v("，这是"),_("strong",[v._v("自动拆箱")]),v._v("，将Integer对象自动拆箱为int")])])])]),v._v(" "),_("h2",{attrs:{id:"什么是b-树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是b-树"}},[v._v("#")]),v._v(" 什么是B+树")]),v._v(" "),_("ul",[_("li",[v._v("m叉的多路平衡查找树")])]),v._v(" "),_("h2",{attrs:{id:"什么是treemap"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是treemap"}},[v._v("#")]),v._v(" 什么是TreeMap")]),v._v(" "),_("ul",[_("li",[v._v("TreeMap是java实现的红黑树数据结构，能比较元素大小的Map集合，"),_("strong",[v._v("会对传入的key进行了大小排序")]),v._v("。其中，可以使用元素的自然顺序，也可以使用集合中自定义的比较器来进行排序")]),v._v(" "),_("li",[v._v("TreeMap 默认排序规则："),_("strong",[v._v("按照key的字典顺序来排序(升序)")])]),v._v(" "),_("li",[v._v("TreeMap实现倒序排序，TreeMap中的"),_("code",[v._v("descendingMap()")]),v._v("可实现")]),v._v(" "),_("li",[v._v("TreeMap实现根据value排序，TreeMap的"),_("code",[v._v("entrySet")]),v._v("返回的值用"),_("code",[v._v("list")]),v._v("存储，然后使用"),_("code",[v._v("Collections.sort")]),v._v("排序")])]),v._v(" "),_("h2",{attrs:{id:"concurrenthashmap"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[v._v("#")]),v._v(" ConcurrentHashMap")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("结构：我们可以将整张"),_("code",[v._v("ConcurrentHashMap")]),v._v("划分成不同的段，每个段可以看做一个"),_("code",[v._v("HashMap")]),v._v("，每个"),_("code",[v._v("HashMap")]),v._v("使用不同的锁，每个段更进一步细分就是entry即实体")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("ConcurrentHashMap")]),v._v("的概念包含"),_("code",[v._v("ConcurrentHashMap")]),v._v("、"),_("code",[v._v("Segment")]),v._v("和"),_("code",[v._v("HashEntry")])])]),v._v(" "),_("li",[_("p",[v._v("读操作不需要加锁，为了确保读操作能够看到最新的值，"),_("strong",[v._v("将value设置成volatile")]),v._v("，这避免了加锁，从而提高了读的效率")])]),v._v(" "),_("li",[_("p",[v._v('JDK1.7版本： 容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的"分段锁"思想')])]),v._v(" "),_("li",[_("p",[v._v("JDK1.8版本：做了2点修改：")]),v._v(" "),_("ul",[_("li",[v._v("取消"),_("code",[v._v("segments")]),v._v("字段，直接采用"),_("code",[v._v("transient volatile HashEntry<K,V>[] table")]),v._v("保存数据，"),_("strong",[v._v("采用HashEntry数组元素作为锁")]),v._v("，从而实现了对每一行数据进行加锁，"),_("strong",[v._v("并发控制使用Synchronized和CAS来操作")])]),v._v(" "),_("li",[v._v("将之前table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构")])])])]),v._v(" "),_("h2",{attrs:{id:"什么是线程池"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是线程池"}},[v._v("#")]),v._v(" 什么是线程池")]),v._v(" "),_("ul",[_("li",[v._v("线程池的好处：\n"),_("ol",[_("li",[v._v("降低资源的消耗")]),v._v(" "),_("li",[v._v("提高响应的速度")]),v._v(" "),_("li",[v._v("方便管理")])])]),v._v(" "),_("li",[v._v("（重点）实现线程复用、可以控制最大并发数、易于管理线程")]),v._v(" "),_("li",[v._v("三大方法：\n"),_("ol",[_("li",[_("code",[v._v("newSingleThreadExecutor()")]),v._v("创建一个单线程化的线程池执行任务")]),v._v(" "),_("li",[_("code",[v._v("newFixedThreadPool(int nThreads)")]),v._v("创建一个固定的线程池的大小")]),v._v(" "),_("li",[_("code",[v._v("newCachedThreadPool()")]),v._v("创建缓存池，可伸缩的， 遇强则强，遇弱则弱")])])]),v._v(" "),_("li",[v._v("七大参数：\n"),_("ol",[_("li",[_("code",[v._v("corePoolSize")]),v._v("：线程池中常驻线程核心线程数")]),v._v(" "),_("li",[_("code",[v._v("maximumPoolSize")]),v._v("：线程池中可容纳最大线程数")]),v._v(" "),_("li",[_("code",[v._v("workQueue")]),v._v("：阻塞队列，储存被提交但未被执行的任务，很重要，会对线程池运行产生重大影响")]),v._v(" "),_("li",[_("code",[v._v("keepAliveTime")]),v._v("：线程没有任务时最多保持多久时间终止")]),v._v(" "),_("li",[_("code",[v._v("unit")]),v._v("："),_("code",[v._v("keepAliveTime")]),v._v("的时间单位")]),v._v(" "),_("li",[_("code",[v._v("threadFactory")]),v._v("：线程工厂，用来创建线程")]),v._v(" "),_("li",[_("code",[v._v("rejectHandler")]),v._v("：当拒绝处理任务时的策略")])])]),v._v(" "),_("li",[v._v("拒绝策略：当任务队列的queue满了的时候，在提交任务，就要触发拒绝策略\n"),_("ol",[_("li",[_("code",[v._v("AbortPolicy")]),v._v("：默认策略，抛出"),_("code",[v._v("RejectedExecutionException")])]),v._v(" "),_("li",[_("code",[v._v("DiscardPolicy")]),v._v("：忽略当前提交的任务")]),v._v(" "),_("li",[_("code",[v._v("DiscardOldestPolicy")]),v._v("：丢弃任务队列中最老的任务，给新任务腾出地方")]),v._v(" "),_("li",[_("code",[v._v("CallerRunsPolicy")]),v._v("：由提交任务者执行这个任务")])])])]),v._v(" "),_("h2",{attrs:{id:"redis事务的概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis事务的概念"}},[v._v("#")]),v._v(" Redis事务的概念")]),v._v(" "),_("ul",[_("li",[v._v("Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会"),_("strong",[v._v("按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中")])]),v._v(" "),_("li",[v._v("总结说："),_("strong",[v._v("redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令")])])]),v._v(" "),_("h2",{attrs:{id:"redis的数据结构及使用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis的数据结构及使用场景"}},[v._v("#")]),v._v(" Redis的数据结构及使用场景")]),v._v(" "),_("ul",[_("li",[v._v("Redis的数据结构有：\n"),_("ol",[_("li",[v._v("字符串：可以用来做最简单的数据缓存，可以"),_("strong",[v._v("缓存某个简单的字符串")]),v._v("，也可以缓存"),_("strong",[v._v("某个json格式的字符串")]),v._v("，"),_("strong",[v._v("Redis分布式锁的实现就利用了这种数据结构")]),v._v("，还包括可以"),_("strong",[v._v("实现计数器、Session共享、分布式ID")])]),v._v(" "),_("li",[v._v("哈希表：可以用来存储一些key-value对，更"),_("strong",[v._v("适合用来存储对象")])]),v._v(" "),_("li",[v._v("列表: Redis的列表通过命令的组合，既可以"),_("strong",[v._v("当做栈，也可以当做队列")]),v._v("来使用，可以用来"),_("strong",[v._v("缓存类似微信朋友圈、微博等消息流数据")])]),v._v(" "),_("li",[v._v("集合：和列表类似，也可以存储多个元素，但是不能重复，集合"),_("strong",[v._v("可以进行交集、并集、差集操作")]),v._v("，从而可以"),_("strong",[v._v("实现类似，我和某人共同关注的人朋友圈点赞等功能")])]),v._v(" "),_("li",[v._v("有序集合：集合是无序的，"),_("strong",[v._v("有序集合可以设置顺序，可以用来实现排行榜功能")])]),v._v(" "),_("li",[v._v("地理位置：用来实现位置，附近的人等功能")]),v._v(" "),_("li",[v._v("基数：有可接受的小误差，用来计算访问量")]),v._v(" "),_("li",[v._v("位图：统计用户信息，活跃，不活跃。登录，未登录。打卡，未打卡")])])])]),v._v(" "),_("h2",{attrs:{id:"redis开启多线程后-是否会存在线程并发安全问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis开启多线程后-是否会存在线程并发安全问题"}},[v._v("#")]),v._v(" Redis开启多线程后，是否会存在线程并发安全问题")]),v._v(" "),_("ul",[_("li",[v._v("Redis的"),_("strong",[v._v("多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行")]),v._v("。所以我们"),_("strong",[v._v("不需要去考虑")]),v._v("控制 key、lua、事务，LPUSH/LPOP 等等的"),_("strong",[v._v("并发及线程安全问题")])])]),v._v(" "),_("h2",{attrs:{id:"说说你了解的分布式锁实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#说说你了解的分布式锁实现"}},[v._v("#")]),v._v(" 说说你了解的分布式锁实现")]),v._v(" "),_("ul",[_("li",[v._v("分布式锁所要解决的问题的本质是："),_("strong",[v._v("能够对分布在多台机器中的线程对共享资源的互斥访问")]),v._v("。在这个原理上可以有很多的实现方式：\n"),_("ol",[_("li",[v._v("基于Mysql，分布式环境中的"),_("strong",[v._v("线程连接同一个数据库，利用数据库中的行锁来达到互斥访问")]),v._v("，但是"),_("strong",[v._v("Mysql的加锁和释放锁的性能会比较低，不适合真正的实际生产环境")])]),v._v(" "),_("li",[v._v("基于Zookeeper，Zookeeper中的数据是存在内存的，所以相对于Mysql性能上是适合实际环境的，并且"),_("strong",[v._v("基于Zookeeper的临时顺序节点和Watch机制能非常好的来实现的分布式锁")])]),v._v(" "),_("li",[v._v("基于Redis，Redis中的数据也是在内存，"),_("strong",[v._v("基于Redis的消费订阅功能、数据超时时间，lua脚本等功能，也能很好的实现的分布式锁")])])])])]),v._v(" "),_("h2",{attrs:{id:"mybatis的优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mybatis的优缺点"}},[v._v("#")]),v._v(" Mybatis的优缺点")]),v._v(" "),_("ul",[_("li",[v._v("优点：\n"),_("ol",[_("li",[_("strong",[v._v("基于SQL语句编程，相当灵活")]),v._v("，不会对应用程序或者数据库的现有设计造成任何影响，"),_("strong",[v._v("SQL写在XML里，解除sql与程序代码的耦合")]),v._v("，便于统一管理；提供XML标签，"),_("strong",[v._v("支持编写动态SQL语句，并可重用")])]),v._v(" "),_("li",[v._v("与JDBC相比，"),_("strong",[v._v("减少了50%以上的代码量，消除了JDBC大量冗余的代码")]),v._v("，不需要手动开关连接")]),v._v(" "),_("li",[v._v("很好的与各种数据库兼容 (因为MyBatis 使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持)")]),v._v(" "),_("li",[_("strong",[v._v("能够与Spring很好的集成")])]),v._v(" "),_("li",[v._v("提供映射标签，支持对象与数据库的ORM字段关系映射;提供对象关系映射标签，支持对象关系组件维护")])])]),v._v(" "),_("li",[v._v("缺点：\n"),_("ol",[_("li",[v._v("SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求")]),v._v(" "),_("li",[_("strong",[v._v("SQL语句依赖于数据库，导致数据库移植性差")]),v._v("，不能随意更换数据库")])])])]),v._v(" "),_("h2",{attrs:{id:"和-的区别是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#和-的区别是什么"}},[v._v("#")]),v._v(" #{}和${}的区别是什么")]),v._v(" "),_("ul",[_("li",[v._v("#{}是"),_("strong",[v._v("预编译处理、是占位符")]),v._v("，${}是"),_("strong",[v._v("字符串替换、是拼接符")])]),v._v(" "),_("li",[v._v("Mybatis在处理#{}时，会"),_("strong",[v._v("将sql中的#{}替换为?号，调用PreparedStatement来赋值")])]),v._v(" "),_("li",[v._v("Mybatis在处理${}时，就是"),_("strong",[v._v("把${}替换成变量的值，调用Statement来赋值")])]),v._v(" "),_("li",[v._v("#{}的变量替换是在DBMS中、变量替换后，#{}对应的变量自动加上单引号")]),v._v(" "),_("li",[v._v("${}的变量替换是在DBMS外、变量替换后，${}对应的变量不会加上单引号")]),v._v(" "),_("li",[v._v("使用**#{}可以有效的防止SQL注入**，提高系统安全性")])]),v._v(" "),_("h2",{attrs:{id:"简述mybatis的插件运行原理-如何编写一个插件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简述mybatis的插件运行原理-如何编写一个插件"}},[v._v("#")]),v._v(" 简述Mybatis的插件运行原理，如何编写一个插件")]),v._v(" "),_("ul",[_("li",[v._v("Mybatis 只支持针对 "),_("code",[v._v("ParameterHandler")]),v._v("、"),_("code",[v._v("ResultSetHandler")]),v._v("、"),_("code",[v._v("StatementHandler")]),v._v("、"),_("code",[v._v("Executor")]),v._v("这4种接口的插件，Mybatis 使用JDK的动态代理，"),_("strong",[v._v("为需要拦截的接口生成代理对象以实现接口方法拦截功能")]),v._v("，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是"),_("code",[v._v("InvocationHandler")]),v._v("的"),_("code",[v._v("invoke()")]),v._v("方法，拦截那些你指定需要拦截的方法")]),v._v(" "),_("li",[v._v("编写插件：实现Mybatis的"),_("code",[v._v("Interceptor")]),v._v("接口并复写"),_("code",[v._v("intercept()")]),v._v("方法，然后再给插件编写注解，指定要拦截哪一个接口的哪些方法即可，在配置文件中配置编写的插件")]),v._v(" "),_("li",[v._v("mybatis-plus就是实现了"),_("code",[v._v("Interceptor")]),v._v("接口并复写"),_("code",[v._v("intercept()")]),v._v("方法实现分页插件和乐观锁插件")])]),v._v(" "),_("h2",{attrs:{id:"说说dubbo的分层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#说说dubbo的分层"}},[v._v("#")]),v._v(" 说说Dubbo的分层")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("从大的范围来说，dubbo分为三层，business业务逻辑层由我们自己来提供接口和实现还有一些配置信息，RPC层就是真正的RPC调用的核心层，封装整个RPC的调用过程、负载均衡、集群容错、代理，remoting则是对网络传输协议和数据转换的封装")])]),v._v(" "),_("li",[_("p",[v._v("划分到更细的层面，就是图中的10层模式，整个分层依赖由上至下，除开business业务逻辑之外，其他的几层都是SPI机制")]),v._v(" "),_("p",[_("img",{attrs:{src:"/%E9%9D%A2%E8%AF%95%E9%A2%98.assets/pic_router.png",alt:"pic_router"}})])])]),v._v(" "),_("h2",{attrs:{id:"dubbo的工作原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dubbo的工作原理"}},[v._v("#")]),v._v(" Dubbo的工作原理")]),v._v(" "),_("ul",[_("li",[v._v("服务启动的时候，生产者和消费者"),_("strong",[v._v("根据配置信息，连接到注册中心register")]),v._v("，分别向注册中心注册和订阅服务")]),v._v(" "),_("li",[_("strong",[v._v("注册中心根据服务订阅关系，返回生产者信息到消费者")]),v._v("，同时"),_("strong",[v._v("消费者会把生产者信息缓存到本地")]),v._v("。如果"),_("strong",[v._v("信息有变更，消费者会收到来自注册中心的推送")])]),v._v(" "),_("li",[_("strong",[v._v("消费者生成代理对象，同时根据负载均衡策略，选择一台生产者")]),v._v("，同时定时向监控中心monitor记录接口的调用次数和时间信息")]),v._v(" "),_("li",[_("strong",[v._v("拿到代理对象之后，消费者通过代理对象发起接口调用")])]),v._v(" "),_("li",[_("strong",[v._v("生产者收到请求后对数据进行反序列化")]),v._v("，然后"),_("strong",[v._v("通过代理调用具体的接口实现")])])]),v._v(" "),_("h2",{attrs:{id:"dubbo为什么要通过代理对象通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dubbo为什么要通过代理对象通信"}},[v._v("#")]),v._v(" Dubbo为什么要通过代理对象通信")]),v._v(" "),_("ul",[_("li",[v._v("主要是为了"),_("strong",[v._v("实现接口的透明代理，封装调用细节")]),v._v("，让用户可以像调用本地方法一样调用远程方法，"),_("strong",[v._v("同时还可以通过代理实现一些其他的策略")]),v._v("，比如：\n"),_("ol",[_("li",[v._v("调用的"),_("strong",[v._v("负载均衡策略")])]),v._v(" "),_("li",[v._v("调用"),_("strong",[v._v("失败、超时、降级和容错机制")])]),v._v(" "),_("li",[v._v("做一些"),_("strong",[v._v("过滤操作")]),v._v("，比如加入缓存、mock数据")]),v._v(" "),_("li",[v._v("接口调用"),_("strong",[v._v("数据统计")])])])])]),v._v(" "),_("h2",{attrs:{id:"dubbo服务暴露的流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dubbo服务暴露的流程"}},[v._v("#")]),v._v(" Dubbo服务暴露的流程")]),v._v(" "),_("ul",[_("li",[v._v("在"),_("strong",[v._v("容器启动的时候，解析标签、注解或配置文件")]),v._v("，"),_("strong",[v._v("容器创建完成之后")]),v._v("，触发ContextRefreshEvent事件回调"),_("strong",[v._v("开始暴露服务")])]),v._v(" "),_("li",[v._v("通过ProxyFactory (代理工厂) 获取到invoker，"),_("strong",[v._v("根据配置信息组装成 URL，传入invoker对象，invoker包含了需要执行的方法的对象信息和具体的URL地址")])]),v._v(" "),_("li",[v._v("再通过DubboProtocol的实现"),_("strong",[v._v("把包装后的invoker转换成exporter，然后启动服务器server，监听端口")])]),v._v(" "),_("li",[v._v("最后RegistryProtocol"),_("strong",[v._v("保存URL地址和invoker的映射关系，同时注册到服务中心")])])]),v._v(" "),_("h2",{attrs:{id:"dubbo服务引用的流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dubbo服务引用的流程"}},[v._v("#")]),v._v(" Dubbo服务引用的流程")]),v._v(" "),_("ul",[_("li",[v._v("服务暴露之后，客户端就要引用服务，然后才是调用的过程")]),v._v(" "),_("li",[v._v("首先"),_("strong",[v._v("客户端根据配置文件信息从注册中心订阅服务")])]),v._v(" "),_("li",[v._v("之后DubboProtocol"),_("strong",[v._v("根据订阅的得到生产者地址和接口信息连接到服务端")]),v._v("server，"),_("strong",[v._v("开启客户端client，然后创建invoker")])]),v._v(" "),_("li",[v._v("invoker创建完成之后，"),_("strong",[v._v("通过invoker为服务接口生成代理对象")]),v._v("，这个"),_("strong",[v._v("代理对象用于远程调用生产者")]),v._v("，服务的引用就完成了")])])])}),[],!1,null,null,null);t.default=a.exports}}]);