(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{472:function(t,v,_){"use strict";_.r(v);var l=_(20),e=Object(l.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"计算机组成与体系结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算机组成与体系结构"}},[t._v("#")]),t._v(" 计算机组成与体系结构")]),t._v(" "),_("h2",{attrs:{id:"数据的表示"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据的表示"}},[t._v("#")]),t._v(" 数据的表示（++++）")]),t._v(" "),_("h3",{attrs:{id:"进制转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进制转换"}},[t._v("#")]),t._v(" 进制转换")]),t._v(" "),_("ul",[_("li",[t._v("R进制转十进制使用按权展开法，其具体操作方式为：\n"),_("ul",[_("li",[t._v("将R进制数的每一位数值用R形式表示，即"),_("strong",[t._v("幂的底数是R，指数为k，k与该位和小数点之间的距离有关")]),t._v("。当该位位于小数点左边，k值是该位和小数点之间数码的个数，而当该位位于小数点右边，k值是负值，其绝对值是该位和小数点之间数码的个数加1")]),t._v(" "),_("li",[t._v("例如"),_("strong",[t._v("二进制")]),t._v("10100.01 = 1×2^4^ + 1×2^2^ + 1×2^-2^")]),t._v(" "),_("li",[t._v("例如"),_("strong",[t._v("七进制")]),t._v("604.01=6×7^2^ + 4×7^0^ + 1×7^-2^")])])]),t._v(" "),_("li",[t._v("十进制转R机制使用"),_("strong",[t._v("短除法")]),t._v("。例如将94转换为二进制数\n"),_("ul",[_("li",[t._v("2 | "),_("u",[t._v("94")]),t._v(" 余0")]),t._v(" "),_("li",[t._v("2 | "),_("u",[t._v("47")]),t._v(" 1")]),t._v(" "),_("li",[t._v("2 | "),_("u",[t._v("23")]),t._v(" 1")]),t._v(" "),_("li",[t._v("2 | "),_("u",[t._v("11")]),t._v(" 1")]),t._v(" "),_("li",[t._v("2 | "),_("u",[t._v("5")]),t._v(" 1")]),t._v(" "),_("li",[t._v("2 | "),_("u",[t._v("2")]),t._v(" 0")]),t._v(" "),_("li",[t._v("1")]),t._v(" "),_("li",[t._v("结果倒着来看，为1011110")]),t._v(" "),_("li",[t._v("小数部分乘R，取整，结果顺着来看")])])]),t._v(" "),_("li",[t._v("二进制转八进制与十六进制\n"),_("ul",[_("li",[t._v("2->8：把二进制数从低位到高位每3位为一份分开，然后算出每一份的数")]),t._v(" "),_("li",[t._v("2->16：把二进制数从低位到高位每4位为一份分开，然后算出每一份的数")]),t._v(" "),_("li",[t._v("小数部分从小数点开始每x位为一份分开")]),t._v(" "),_("li",[t._v("八进制与十六进制转二进制反着来")])])])]),t._v(" "),_("h3",{attrs:{id:"码制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#码制"}},[t._v("#")]),t._v(" 码制")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("分别是原码，反码，补码，移码")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}},[t._v("码制")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("数值1")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("数值-1")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("计算1-1")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("原码")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("0000 0001")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("1000 0001")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("1000 0010 ×")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("反码")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("0000 0001")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("1111 1110")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("1111 1111 ×")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("补码")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("0000 0001")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("1111 1111")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("0000 0000 √")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("移码")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("1000 0001")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("0111 1111")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("1000 0000 ×")])])])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("原码：")])]),t._v(" "),_("ul",[_("li",[t._v("高位为符号位，0表示正数，1表示负数")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("反码：")])]),t._v(" "),_("ul",[_("li",[t._v("正数的反码等于它本身")]),t._v(" "),_("li",[t._v("负数的反码等于除符号位其他位取反")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("补码：")])]),t._v(" "),_("ul",[_("li",[t._v("正数的补码等于它本身")]),t._v(" "),_("li",[t._v("负数的补码等于在反码的基础上+1")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("移码：")])]),t._v(" "),_("ul",[_("li",[t._v("在补码的基础上符号位取反")])])]),t._v(" "),_("li",[_("p",[t._v("数值表示范围")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}},[t._v("码制")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("定点整数（最高位符号位）")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("定点小数（小数点在符号位后面）")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("原码")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("-(2^n-1^-1) ~ +(2^n-1^-1)")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("-(1-2^-(n-1)^) ~ +(1-2^-(n-1)^)")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("反码")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("-(2^n-1^-1) ~ +(2^n-1^-1)")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("-(1-2^-(n-1)^) ~ +(1-2^-(n-1)^)")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("补码")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("-2^n-1^ ~ +(2^n-1^-1)")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("-1 ~ +(1-2^-(n-1)^)")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("移码")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("-2^n-1^ ~ +(2^n-1^-1)")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("-1 ~ +(1-2^-(n-1)^)")])])])]),t._v(" "),_("ul",[_("li",[t._v("补码和移码比原码和反码少一个数：-0")])])]),t._v(" "),_("li",[_("p",[t._v("定点整数：")]),t._v(" "),_("ul",[_("li",[t._v("当n=8时")]),t._v(" "),_("li",[t._v("原码：-127~127，二进制：1111 1111 ~ 0111 1111")]),t._v(" "),_("li",[t._v("补码：1000 0000  ~ 0111 1111")]),t._v(" "),_("li",[t._v("其中-128的补码为1000 0000是人为规定的")])])]),t._v(" "),_("li",[_("p",[t._v("定点小数：")]),t._v(" "),_("ul",[_("li",[t._v("当n=8时")]),t._v(" "),_("li",[t._v("原码：-0.1111111 ~ +0.1111111，二进制：1.111 1111 ~ 0.111 1111")]),t._v(" "),_("li",[t._v("补码：1.000 0000 ~ 0.111 1111")]),t._v(" "),_("li",[t._v("其中-1的补码为1.000 0000是人为规定的")])])])]),t._v(" "),_("h3",{attrs:{id:"浮点的运算"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浮点的运算"}},[t._v("#")]),t._v(" 浮点的运算")]),t._v(" "),_("ul",[_("li",[t._v("浮点数的表示：N=尾数*基数^指数(阶码)^（科学计数法）")]),t._v(" "),_("li",[t._v("运算过程：对阶 > 尾数计算 > 结果格式化")]),t._v(" "),_("li",[t._v("特点：\n"),_("ol",[_("li",[t._v("一般尾数用"),_("strong",[t._v("补码")]),t._v("，阶码用"),_("strong",[t._v("移码")])]),t._v(" "),_("li",[_("strong",[t._v("阶码的位数")]),t._v("决定数的"),_("strong",[t._v("表示范围")]),t._v("，位数越多范围越大")]),t._v(" "),_("li",[_("strong",[t._v("尾数的位数")]),t._v("决定数的"),_("strong",[t._v("有效精度")]),t._v("，位数越多精度越高")]),t._v(" "),_("li",[t._v("对阶时，"),_("strong",[t._v("小数向大数看齐")])]),t._v(" "),_("li",[t._v("对阶是通过"),_("strong",[t._v("较小数的小数点左移")]),t._v("实现的")])])])]),t._v(" "),_("h2",{attrs:{id:"运算器与控制器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运算器与控制器"}},[t._v("#")]),t._v(" 运算器与控制器（++++）")]),t._v(" "),_("h3",{attrs:{id:"计算机结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算机结构"}},[t._v("#")]),t._v(" 计算机结构")]),t._v(" "),_("ul",[_("li",[t._v("五大部件：运算器，控制器，存储器，输入设备，输出设备")]),t._v(" "),_("li",[t._v("CPU由运算器、控制器、寄存器组和内部总线组成")]),t._v(" "),_("li",[t._v("运算器包含：\n"),_("ul",[_("li",[_("strong",[t._v("算数逻辑单元ALU：数据的算术运算和逻辑运算")])]),t._v(" "),_("li",[t._v("累加寄存器AC：通用寄存器，为ALU提供一个工作区，用在暂存数")]),t._v(" "),_("li",[t._v("数据缓冲寄存器DR：写内存时，暂存指令或数据")]),t._v(" "),_("li",[t._v("状态条件寄存器：存状态标志与控制标志(争议:也有将其归为控制器的)")])])]),t._v(" "),_("li",[t._v("控制器包含：\n"),_("ul",[_("li",[_("strong",[t._v("程序计数器PC：存储下一条要执行指令的地址")])]),t._v(" "),_("li",[t._v("指令寄存器IR：存储即将执行的指令")]),t._v(" "),_("li",[t._v("指令译码器ID：对指令中的操作码字段进行分析解释")]),t._v(" "),_("li",[t._v("时序部件：提供时序控制信号")])])])]),t._v(" "),_("h3",{attrs:{id:"指令的基本概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#指令的基本概念"}},[t._v("#")]),t._v(" 指令的基本概念")]),t._v(" "),_("ul",[_("li",[t._v("一条指令就是机器语言的一个语句，它是一组有意义的二进制代码，指令的基本格式如下：\n"),_("ul",[_("li",[t._v("操作码字段 | 地址码字段")])])]),t._v(" "),_("li",[t._v("操作码部分指出了计算机要执行什么性质的操作，如加法、减法、取数存数等。地址码字段需要包含各操作数的地址及操作结果的存放地址等，从其地址结构的角度可以分为三地址指令、二地址指令、一地址指令和零地址指令\n"),_("ul",[_("li",[t._v("OP | A1 | A2 | A3")]),t._v(" "),_("li",[t._v("OP | A1 | A2")]),t._v(" "),_("li",[t._v("OP | A1")]),t._v(" "),_("li",[t._v("OP")]),t._v(" "),_("li",[t._v("OP代表操作")]),t._v(" "),_("li",[t._v("例如：a+b=c -> + | a | b | c")])])])]),t._v(" "),_("h3",{attrs:{id:"寻址方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#寻址方式"}},[t._v("#")]),t._v(" 寻址方式")]),t._v(" "),_("ul",[_("li",[t._v("立即导址方式\n"),_("ul",[_("li",[t._v("特点：操作数直接在指令中，速度快，灵活性差")])])]),t._v(" "),_("li",[t._v("直接寻址方式\n"),_("ul",[_("li",[t._v("特点：指令中存放的是操作数的地址")])])]),t._v(" "),_("li",[t._v("间接寻址方式\n"),_("ul",[_("li",[t._v("特点：指令中存放了一个地址，这个地址对应的内容是操作数的地址")])])]),t._v(" "),_("li",[t._v("寄存器寻址方式\n"),_("ul",[_("li",[t._v("特点：寄存器存放操作数")])])]),t._v(" "),_("li",[t._v("寄存器间接导址方式\n"),_("ul",[_("li",[t._v("特点：奇存器内存放的是操作数的地址")])])])]),t._v(" "),_("h2",{attrs:{id:"flynn分类法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#flynn分类法"}},[t._v("#")]),t._v(" Flynn分类法（++）")]),t._v(" "),_("ul",[_("li",[t._v("按并行程度进行分类\n"),_("ul",[_("li",[t._v("S：single单一，I：instructions指令，D：data，M：Multiple多的")])])])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}},[t._v("体系结构类型")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("结构")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("关键特性")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("代表")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("单指令流单数据流 SISD")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("控制部分：一个 | 处理器：一个 | 主存模块：一个")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}}),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("单处理器系统")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("单指令流多数据流 SIMD")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("控制部分：一个 | 处理器：多个 | 主存模块：多个")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("各处理器以异步的形式执行同一条指令")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("并列处理机、"),_("strong",[t._v("阵列处理机")]),t._v("、超级向量处理机")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("多指令流单数据流 MISD")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("控制部分：多个 | 处理器：一个 | 主存模块：多个")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("被证明不可能，至少是不实际")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("目前没有，有文献称流水线计算机为此类")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("多指令流多数据流 MIMD")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("控制部分：多个 | 处理器：多个 | 主存模块：多个")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("能够实现"),_("strong",[t._v("作业、任务、指令")]),t._v("等各级全面并行")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("多处理机系统、多计算机")])])])]),t._v(" "),_("h2",{attrs:{id:"cisc与risc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cisc与risc"}},[t._v("#")]),t._v(" CISC与RISC（++）")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}},[t._v("指令系统类型")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("指令")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("寻址方式")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("实现方式")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("其他")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("CISC（复杂）")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("数量多，使用频率差别大，可变长格式")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("支持多种")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("微程序控制技术（微码）")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("研制周期长")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("RISC（精简）")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("数量少，使用频率接近，定长格式，大部分为单周期指令操作寄存器，只有Load/Store操作内存")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("支持方式少")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("增加了通用寄存器，硬布线逻辑控制为主，适合采用流水线")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("优化编译，有效支持高级语言")])])])]),t._v(" "),_("ul",[_("li",[t._v("CISC：复杂指令集计算机 Complex Instruction Set Computer 复杂，指令数量多，频率差别大，多寻址")]),t._v(" "),_("li",[t._v("RISC：精简指令集计算机 Reduced Instruction Set Computing 精简，指令数量少，操作寄存器，单周期，少寻址，多通用寄存器，流水线")])]),t._v(" "),_("h2",{attrs:{id:"流水线技术"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#流水线技术"}},[t._v("#")]),t._v(" 流水线技术（++++）")]),t._v(" "),_("ul",[_("li",[t._v("流水线概念：\n"),_("ul",[_("li",[t._v("相关参数计算："),_("strong",[t._v("流水线执行时间计算、流水线吞吐率")]),t._v("、流水线加速比、流水线效率")]),t._v(" "),_("li",[t._v("流水线是指在程序执行时"),_("strong",[t._v("多条指令重叠进行操作")]),t._v("的一种"),_("strong",[t._v("准并行处理实现技术")]),t._v("，将"),_("strong",[t._v("空余的时间片利用起来")]),t._v("。各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作以提高各部件的利用率和指令的平均执行速度")])])]),t._v(" "),_("li",[t._v("流水线计算：\n"),_("ul",[_("li",[t._v("流水线周期为执行时间最长的一段")]),t._v(" "),_("li",[t._v("流水线计算公式为:\n"),_("ul",[_("li",[_("strong",[t._v("1条指令执行时间＋(指令条数 - 1) * 流水线周期")])]),t._v(" "),_("li",[t._v("一条指令k个步骤给充足时间执行公式："),_("strong",[t._v("k * 流水线周期 + (指令条数 - 1) * 流水线周期")])])])]),t._v(" "),_("li",[t._v("例题：\n"),_("ul",[_("li",[t._v("一条指令的执行过程可以分解为取指、分析和执行三步，在取址时间t取指=3△t、分析时间t分析=2△t、执行时间t执行=4△t的情况下，若按串行方式执行，则10条指令全部执行完需要（）△t；若按流水线的方式执行，流水线周期为（）△t，则10条指令全部执行完需要（）△t")]),t._v(" "),_("li",[t._v("答案：90，4，45")])])])])]),t._v(" "),_("li",[t._v("超标量流水线：由两条流水线组成，度为2，能同时进行两个操作比如两个取址")]),t._v(" "),_("li",[t._v("流水线吞吐率：\n"),_("ul",[_("li",[t._v("流水线的吞吐率（Though Put rate，TP）是指在"),_("strong",[t._v("单位时间内流水线所完成的任务数量或输出的结果数量")]),t._v("。计算流水线吞吐率的最基本的公式如下：\n"),_("ul",[_("li",[t._v("TP=指令条数 / 流水线执行时间")])])]),t._v(" "),_("li",[t._v("流水线最大吞吐率：\n"),_("ul",[_("li",[t._v("TP(max)=Lim(n->∞) n / ((k+n-1)*△t)=1 / △t")])])])])])]),t._v(" "),_("h2",{attrs:{id:"存储系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#存储系统"}},[t._v("#")]),t._v(" 存储系统（++++）")]),t._v(" "),_("h3",{attrs:{id:"层次化存储结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#层次化存储结构"}},[t._v("#")]),t._v(" 层次化存储结构")]),t._v(" "),_("ul",[_("li",[t._v("（速度快，容量小）CPU---Cache---内存（主存）---外存（辅存）（速度慢，容量大）")]),t._v(" "),_("li",[t._v("CPU：寄存器，最快，但容量小，成本高")]),t._v(" "),_("li",[t._v("Cache：按内容存取，在计算机的存储系统体系中，Cache是访问速度最快的层次（若有寄存器，则寄存器最快），使用Cache改善系统性能的依据是程序的局部性原理\n"),_("ul",[_("li",[t._v('如果以h代表Cache的访问命中率，t1表示Cache的周期，t2表示主存周期，以读操作为例，使用"Cache+主存"的系统平均周期为t3，则：\n'),_("ul",[_("li",[t._v("t3 = h×t1+(1-h)×t2")]),t._v(" "),_("li",[t._v("其中，(1-h)又称为失效率（未命中率）")])])]),t._v(" "),_("li",[t._v("映像：\n"),_("ul",[_("li",[_("strong",[t._v("直接相联映像")]),t._v("：硬件电路较简单，但"),_("strong",[t._v("冲突率很高")])]),t._v(" "),_("li",[_("strong",[t._v("全相联映像")]),t._v("：电路难于设计和实现，只适用于小容量的cache，"),_("strong",[t._v("冲突率较低")])]),t._v(" "),_("li",[_("strong",[t._v("组相联映像")]),t._v("：直接相联与全相联的"),_("strong",[t._v("折中")])]),t._v(" "),_("li",[t._v("地址映像是将主存与Cache的存储空间划分为若干大小相同的页（或称为块）\n"),_("ul",[_("li",[t._v("例如，某机的主存容量为1GB，划分为2048页，每页512KB；Cache容量为8MB，划分为16页，每页512KB\n"),_("ul",[_("li",[t._v("主存分为128个区，每个区16页，直接相联映像只能存每个区对应页数的内容，而且一次只能放一个区的对应页数")]),t._v(" "),_("li",[t._v("组相联映像在直接相联映像的基础上把多个页分为一组，每个组存对应组的内容")])])])])])])])])]),t._v(" "),_("li",[t._v("内存：分为随机存储器（RAM）和只读存储器（ROM）")]),t._v(" "),_("li",[t._v("外存：硬盘，光盘，U盘等")])]),t._v(" "),_("h3",{attrs:{id:"编址与计算"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#编址与计算"}},[t._v("#")]),t._v(" 编址与计算")]),t._v(" "),_("ul",[_("li",[t._v("按字编址：存储体的存储单元是字存储单元，即最小寻址单位是一个字，2字节")]),t._v(" "),_("li",[t._v("按字节编址：存储体的存储单元是字节存储单元;即最小寻址单位是字节，1字节(Byte) = 8位(bit)")]),t._v(" "),_("li",[t._v("根据存储器所要求的容量和选定的存储芯片的容量，就可以计算出所需芯片的总数，即：\n"),_("ul",[_("li",[t._v("总片数 = 总容量 / 每片的容量")])])]),t._v(" "),_("li",[t._v("例题：\n"),_("ul",[_("li",[t._v("若内存地址区间为4000H ~43FFH，每个存储单元可存储16位二制数，该内存区域用4片存储器芯片构成，则构成该内存所用的存储器芯片的容量是多少?")]),t._v(" "),_("li",[t._v("答案：容量：43FFH - 4000H + 1 (区间计算要+1)= 400H = 2^10^ × 16bit，有4片于是每片为2^10^ × 4bit")])])])]),t._v(" "),_("h2",{attrs:{id:"总线系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总线系统"}},[t._v("#")]),t._v(" 总线系统（+）")]),t._v(" "),_("ul",[_("li",[t._v("总线是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束， 按照计算机所传输的信息种类")]),t._v(" "),_("li",[t._v("一条总线"),_("strong",[t._v("同一时刻仅允许一个设备发送，但允许多个设备接收")])]),t._v(" "),_("li",[t._v("总线的分类：\n"),_("ul",[_("li",[t._v("数据总线（Data Bus)：在CPU与RAM之间来回传送需要处理或是需要储存的数据")]),t._v(" "),_("li",[t._v("地址总线（Address Bus）：用来指定在RAM ( Random Access Memory）之中储存的数据的地址")]),t._v(" "),_("li",[t._v("控制总线（Control Bus）：将微处理器控制单元（Control Unit)的信号，传送到周边设备，一般常见的为USB Bus和1394 Bus")])])])]),t._v(" "),_("h2",{attrs:{id:"串联系统与并联系统可靠性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#串联系统与并联系统可靠性"}},[t._v("#")]),t._v(" 串联系统与并联系统可靠性（+）")]),t._v(" "),_("ul",[_("li",[t._v("串联系统可靠性：所有系统可靠性的乘积 R=R1×R2×R3...×Rn")]),t._v(" "),_("li",[t._v("并联系统可靠性：1-每个系统出错概率相乘 R=1-(1-R1)×(1-R2)×...×(1-Rn)")]),t._v(" "),_("li",[t._v("N模混合系统：串并联结合")])]),t._v(" "),_("h2",{attrs:{id:"校验码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#校验码"}},[t._v("#")]),t._v(" 校验码（+++）")]),t._v(" "),_("ul",[_("li",[t._v("码距：任何一种编码都由许多码字构成，"),_("strong",[t._v("任意两个码字之间最少变化的二进制位数就称为数据校验码的码距")])]),t._v(" "),_("li",[t._v("例如，用"),_("strong",[t._v("4位二进制表示16种状态")]),t._v("，则有"),_("strong",[t._v("16个不同的码字")]),t._v("，此时"),_("strong",[t._v("码距为1")]),t._v("，如0000与0001。")])]),t._v(" "),_("h3",{attrs:{id:"奇偶校验"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#奇偶校验"}},[t._v("#")]),t._v(" 奇偶校验")]),t._v(" "),_("ul",[_("li",[t._v("奇偶校验码的编码方法是：由若干位有效信息（如一个字节)，再加上一个二进制位（校验位）组成校验码")]),t._v(" "),_("li",[t._v('奇校验：整个校验码（有效信息位和校验位）中"1"的个数为奇数')]),t._v(" "),_("li",[t._v('偶校验：整个校验码（有效信息位和校验位）中"1"的个数为偶数')]),t._v(" "),_("li",[_("strong",[t._v("奇偶校验，可检查1位的错误，不可纠错")])])]),t._v(" "),_("h3",{attrs:{id:"循环冗余校验crc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#循环冗余校验crc"}},[t._v("#")]),t._v(" 循环冗余校验CRC")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("CRC校验，可检错，不可纠错")])]),t._v(" "),_("li",[t._v("CRC的编码方法是：在k位信息码之后拼接r位校验码。应用CRC码的关键是如何从k位信息位简便地得到r位校验位（编码），以及如何从k+r位信息码判断是否出错")]),t._v(" "),_("li",[t._v("用模2除法，在运算过程中不计进位的除法，对好位即可（最高位须对其）")]),t._v(" "),_("li",[t._v("例题：\n"),_("ul",[_("li",[t._v("信息码为1 0111 0101，多项式为X^4^+X^2^+1，求冗余位\n"),_("ul",[_("li",[t._v("最高项指数为4，所以被除数补4个0 -> 1 0111 0101 0000")]),t._v(" "),_("li",[t._v("除数为把2带入多项式得出的结果的二进制（X的n次方就是第n+1位为1，其他位为0），所以是10101")]),t._v(" "),_("li",[t._v("然后用模2除法计算，最后的余数即为冗余位，也就是CRC校验码（4位），补到之前的4个0处后，就是使用了CRC的报文")])])])])])]),t._v(" "),_("h3",{attrs:{id:"海明校验码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#海明校验码"}},[t._v("#")]),t._v(" 海明校验码")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("海明校验，可检错，也可纠错")])]),t._v(" "),_("li",[t._v("海明校验码的原理是：在有效信息位中加入几个校验位形成海明码，使码距比较均匀地拉大，并把海明码的每个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错误，还能指出错误的位置，为自动纠错提供了依据")]),t._v(" "),_("li",[_("strong",[t._v("2^r^ >= m+r+1")]),t._v("，r：校验位，m：数据位")])])])}),[],!1,null,null,null);v.default=e.exports}}]);